--- LexMake.cxx	2017-04-01 19:11:22.000000000 +0200
+++ LexMake_mod.cxx	2017-05-25 22:05:06.000000000 +0200
@@ -6,6 +6,7 @@
 // The License.txt file describes the conditions under which this software may be distributed.
 
 #include <stdlib.h>
+#include <iostream>
 #include <string.h>
 #include <stdio.h>
 #include <stdarg.h>
@@ -37,11 +38,14 @@
     Sci_PositionU lengthLine,
     Sci_PositionU startLine,
     Sci_PositionU endPos,
+    WordList *keywordlists[],
     Accessor &styler) {
 
 	Sci_PositionU i = 0;
 	Sci_Position lastNonSpace = -1;
 	unsigned int state = SCE_MAKE_DEFAULT;
+	unsigned int state_prev = SCE_MAKE_DEFAULT;
+
 	bool bSpecial = false;
 
 	// check for a tab character in column 0 indicating a command
@@ -53,6 +57,10 @@
 	while ((i < lengthLine) && isspacechar(lineBuffer[i])) {
 		i++;
 	}
+	
+	// Create Word Buffer for current Line (from lexBatch)
+	std::string wordBuffer;	// Word Buffer  
+	
 	if (i < lengthLine) {
 		if (lineBuffer[i] == '#') {	// Comment
 			styler.ColourTo(endPos, SCE_MAKE_COMMENT);
@@ -63,17 +71,70 @@
 			return;
 		}
 	}
-	int varCount = 0;
+
+	int varCount = 0; // increments on $
+	int inVarCount = 0; // increments on identifiers within $vars @...D/F
+	
+	std::string tmp;
 	while (i < lengthLine) {
-		if (((i + 1) < lengthLine) && (lineBuffer[i] == '$' && lineBuffer[i + 1] == '(')) {
+	
+		tmp=lineBuffer[i]; // convert linebuffer to be std::string 
+		wordBuffer.append(tmp);
+		
+		// color keywords within current line
+		WordList &kwDirective = *keywordlists[0]; // Makefile->generic kwds
+		
+		// search for longest keyword match backwards from current position. case dependent.
+		std::string wordPart; 
+		unsigned int longest_match=0;
+		unsigned int matchpos=0;
+		for (matchpos=0; matchpos<=wordBuffer.size(); matchpos++) {
+			wordPart.insert(0,wordBuffer.substr(wordBuffer.size()-matchpos, 1));
+			if (kwDirective.InList(wordPart.c_str())) {
+			longest_match=matchpos;
+			}
+		}
+		
+		if (longest_match>0) {
+			styler.ColourTo(startLine +i -longest_match ,state );
+			state_prev = state;
+			state=SCE_MAKE_OPERATOR;
+		} else if (longest_match==0 && state==SCE_MAKE_OPERATOR){
+			styler.ColourTo(startLine +i-1 ,state );
+			state=state_prev;
+		}
+		
+		
+		// Style for Variables $(...) 
+		if (((i + 1) < lengthLine) && lineBuffer[i] == '$' && lineBuffer[i+1] == '(')  {
 			styler.ColourTo(startLine + i - 1, state);
-			state = SCE_MAKE_IDENTIFIER;
+			state = SCE_MAKE_VARIABLE;
 			varCount++;
-		} else if (state == SCE_MAKE_IDENTIFIER && lineBuffer[i] == ')') {
+		// and $ based automatic Variables $@
+		} else if (((i + 1) < lengthLine) && lineBuffer[i] == '$' && (strchr( "@%<?^+*",(int)lineBuffer[i+1]) >0) ) {
+			styler.ColourTo(startLine + i -1, state);
+			state = SCE_MAKE_AUTOM_VARIABLE;
+			} else if ((state == SCE_MAKE_VARIABLE || state == SCE_MAKE_AUTOM_VARIABLE) && lineBuffer[i]==')') {
 			if (--varCount == 0) {
 				styler.ColourTo(startLine + i, state);
+				state = state_prev;
+			}
+		} else if (state == SCE_MAKE_AUTOM_VARIABLE && (strchr( "@%<?^+*",(int)lineBuffer[i]) >0) && lineBuffer[i-1]=='$') {
+				styler.ColourTo(startLine + i, state);
 				state = SCE_MAKE_DEFAULT;
 			}
+		
+		// Style for automatic Variables in standard variables (@%<^+)
+		if (((i + 1) < lengthLine) && (strchr( "@%<?^+*",(int)lineBuffer[i]) >0) && (strchr( "DF",(int)lineBuffer[i+1]) >0))  {
+			styler.ColourTo(startLine + i -1 , state);
+			state_prev=state;
+			state = SCE_MAKE_AUTOM_VARIABLE;
+			inVarCount++;
+		} else if (state == SCE_MAKE_AUTOM_VARIABLE && (strchr( "@%<^+",(int)lineBuffer[i-1]) >0) && (strchr( "DF",(int)lineBuffer[i]) >0)) {
+			if (--inVarCount == 0) {
+				styler.ColourTo(startLine + i-1, state);
+				state = state_prev;
+			}
 		}
 
 		// skip identifier and target styling if this is a command line
@@ -84,39 +145,49 @@
 					if (lastNonSpace >= 0)
 						styler.ColourTo(startLine + lastNonSpace, SCE_MAKE_IDENTIFIER);
 					styler.ColourTo(startLine + i - 1, SCE_MAKE_DEFAULT);
-					styler.ColourTo(startLine + i + 1, SCE_MAKE_OPERATOR);
+					styler.ColourTo(startLine + i + 1, SCE_MAKE_DEFAULT);
 				} else {
 					// We should check that no colouring was made since the beginning of the line,
 					// to avoid colouring stuff like /OUT:file
 					if (lastNonSpace >= 0)
 						styler.ColourTo(startLine + lastNonSpace, SCE_MAKE_TARGET);
-					styler.ColourTo(startLine + i - 1, SCE_MAKE_DEFAULT);
+					styler.ColourTo(startLine + i - 1, state_prev);
 					styler.ColourTo(startLine + i, SCE_MAKE_OPERATOR);
 				}
 				bSpecial = true;	// Only react to the first ':' of the line
-				state = SCE_MAKE_DEFAULT;
+				state = state_prev;
 			} else if (lineBuffer[i] == '=') {
 				if (lastNonSpace >= 0)
 					styler.ColourTo(startLine + lastNonSpace, SCE_MAKE_IDENTIFIER);
-				styler.ColourTo(startLine + i - 1, SCE_MAKE_DEFAULT);
+				styler.ColourTo(startLine + i - 1, state_prev);
 				styler.ColourTo(startLine + i, SCE_MAKE_OPERATOR);
 				bSpecial = true;	// Only react to the first '=' of the line
-				state = SCE_MAKE_DEFAULT;
+				state = state_prev;				
+			} else if (lineBuffer[i] == '{') {		
+				styler.ColourTo(startLine + i - 1, state_prev);			
+				styler.ColourTo(startLine + i, SCE_MAKE_TARGET);
+				state = state_prev;
+			} else if (lineBuffer[i] == '}') {
+				styler.ColourTo(startLine + i - 1, state_prev);	
+				styler.ColourTo(startLine + i, SCE_MAKE_TARGET);
+				state = state_prev;
 			}
+
 		}
 		if (!isspacechar(lineBuffer[i])) {
 			lastNonSpace = i;
 		}
 		i++;
 	}
+	
 	if (state == SCE_MAKE_IDENTIFIER) {
 		styler.ColourTo(endPos, SCE_MAKE_IDEOL);	// Error, variable reference not ended
 	} else {
-		styler.ColourTo(endPos, SCE_MAKE_DEFAULT);
+		styler.ColourTo(endPos, state_prev);
 	}
 }
 
-static void ColouriseMakeDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler) {
+static void ColouriseMakeDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywords[], Accessor &styler) {
 	char lineBuffer[1024];
 	styler.StartAt(startPos);
 	styler.StartSegment(startPos);
@@ -127,18 +198,19 @@
 		if (AtEOL(styler, i) || (linePos >= sizeof(lineBuffer) - 1)) {
 			// End of line (or of line buffer) met, colourise it
 			lineBuffer[linePos] = '\0';
-			ColouriseMakeLine(lineBuffer, linePos, startLine, i, styler);
+			ColouriseMakeLine(lineBuffer, linePos, startLine, i, keywords, styler);
 			linePos = 0;
 			startLine = i + 1;
 		}
 	}
 	if (linePos > 0) {	// Last line does not have ending characters
-		ColouriseMakeLine(lineBuffer, linePos, startLine, startPos + length - 1, styler);
+		ColouriseMakeLine(lineBuffer, linePos, startLine, startPos + length - 1, keywords, styler);
 	}
 }
 
-static const char *const emptyWordListDesc[] = {
+static const char *const makefileWordListDesc[] = {
+	"generic",
 	0
 };
 
-LexerModule lmMake(SCLEX_MAKEFILE, ColouriseMakeDoc, "makefile", 0, emptyWordListDesc);
+LexerModule lmMake(SCLEX_MAKEFILE, ColouriseMakeDoc, "makefile", 0, makefileWordListDesc);

--- SciLexer.h	2017-04-14 20:58:48.000000000 +0200
+++ SciLexer_mod.h	2017-05-24 22:10:04.000000000 +0200
@@ -548,6 +548,8 @@
 #define SCE_MAKE_IDENTIFIER 3
 #define SCE_MAKE_OPERATOR 4
 #define SCE_MAKE_TARGET 5
+#define SCE_MAKE_VARIABLE 6
+#define SCE_MAKE_AUTOM_VARIABLE 7
 #define SCE_MAKE_IDEOL 9
 #define SCE_DIFF_DEFAULT 0
 #define SCE_DIFF_COMMENT 1
