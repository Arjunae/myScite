--- LexMake.cxx	2017-04-01 19:11:22.000000000 +0200
+++ LexMake_mod.cxx	2017-05-24 21:12:40.000000000 +0200
@@ -37,6 +37,7 @@
     Sci_PositionU lengthLine,
     Sci_PositionU startLine,
     Sci_PositionU endPos,
+		WordList *keywordlists[],
     Accessor &styler) {
 
 	Sci_PositionU i = 0;
@@ -44,6 +45,16 @@
 	unsigned int state = SCE_MAKE_DEFAULT;
 	bool bSpecial = false;
 
+	/*
+	// todo fetch current word to search for below
+	WordList &kwDirective = *keywordlists[0]; // Directives
+
+	if (kwDirective.InList(words)) {
+		styler.ColourTo(endPos, SCE_MAKE_VARIABLE);
+		return;
+	}	
+	*/
+	
 	// check for a tab character in column 0 indicating a command
 	bool bCommand = false;
 	if ((lengthLine > 0) && (lineBuffer[0] == '\t'))
@@ -63,16 +74,39 @@
 			return;
 		}
 	}
-	int varCount = 0;
+	
+	int varCount = 0; // increments on $
+	int inVarCount = 0; // increments on identifiers within $vars @...D/F
+	unsigned int state_prev;
 	while (i < lengthLine) {
-		if (((i + 1) < lengthLine) && (lineBuffer[i] == '$' && lineBuffer[i + 1] == '(')) {
+		// same Style for Variables $(...) and $ based automatic Variables $@
+		if (((i + 1) < lengthLine) && lineBuffer[i] == '$' && (strchr( "(@%<?^+*",(int)lineBuffer[i+1]) >0))  {
 			styler.ColourTo(startLine + i - 1, state);
-			state = SCE_MAKE_IDENTIFIER;
+			state_prev = state;
+			state = SCE_MAKE_VARIABLE;
 			varCount++;
-		} else if (state == SCE_MAKE_IDENTIFIER && lineBuffer[i] == ')') {
+		} else if (state == SCE_MAKE_VARIABLE && lineBuffer[i]==')') {
 			if (--varCount == 0) {
 				styler.ColourTo(startLine + i, state);
-				state = SCE_MAKE_DEFAULT;
+				state = state_prev;
+			}
+		} else if (state == SCE_MAKE_VARIABLE && (strchr( "@%<?^+*",(int)lineBuffer[i]) >0) && lineBuffer[i-1]=='$') {
+			if (--varCount == 0) {
+				styler.ColourTo(startLine + i, state);
+				state = state_prev;
+			}
+		}
+		
+		// Style for automatic Variables in standard variables (@%<^+)
+		if (((i + 1) < lengthLine) && (strchr( "@%<?^+*",(int)lineBuffer[i]) >0) && (strchr( "DF",(int)lineBuffer[i+1]) >0))  {
+			styler.ColourTo(startLine + i -1 , state);
+			state_prev=state;
+			state = SCE_MAKE_IN_VARIABLE;
+			inVarCount++;
+		} else if (state == SCE_MAKE_IN_VARIABLE && (strchr( "@%<^+",(int)lineBuffer[i-1]) >0) && (strchr( "DF",(int)lineBuffer[i]) >0)) {
+			if (--inVarCount == 0) {
+				styler.ColourTo(startLine + i, state);
+				state = state_prev;
 			}
 		}
 
@@ -107,8 +141,10 @@
 		if (!isspacechar(lineBuffer[i])) {
 			lastNonSpace = i;
 		}
+		
 		i++;
 	}
+	
 	if (state == SCE_MAKE_IDENTIFIER) {
 		styler.ColourTo(endPos, SCE_MAKE_IDEOL);	// Error, variable reference not ended
 	} else {
@@ -116,7 +152,7 @@
 	}
 }
 
-static void ColouriseMakeDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler) {
+static void ColouriseMakeDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywords[], Accessor &styler) {
 	char lineBuffer[1024];
 	styler.StartAt(startPos);
 	styler.StartSegment(startPos);
@@ -127,13 +163,13 @@
 		if (AtEOL(styler, i) || (linePos >= sizeof(lineBuffer) - 1)) {
 			// End of line (or of line buffer) met, colourise it
 			lineBuffer[linePos] = '\0';
-			ColouriseMakeLine(lineBuffer, linePos, startLine, i, styler);
+			ColouriseMakeLine(lineBuffer, linePos, startLine, i, keywords, styler);
 			linePos = 0;
 			startLine = i + 1;
 		}
 	}
 	if (linePos > 0) {	// Last line does not have ending characters
-		ColouriseMakeLine(lineBuffer, linePos, startLine, startPos + length - 1, styler);
+		ColouriseMakeLine(lineBuffer, linePos, startLine, startPos + length - 1, keywords, styler);
 	}
 }
 
