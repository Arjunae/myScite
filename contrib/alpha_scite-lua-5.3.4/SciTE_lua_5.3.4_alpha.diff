--- LuaExtension_orig.cxx	2016-10-16 04:59:54.000000000 +0200
+++ LuaExtension.cxx	2017-03-27 06:52:16.000000000 +0200
@@ -24,12 +24,18 @@
 #include "IFaceTable.h"
 #include "SciTEKeys.h"
 
+//define lua_pushglobaltable(L) lua_pushvalue(L, LUA_GLOBALSINDEX)
+//define lua_pushglobaltable(L) lua_rawgeti(pLuaState, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);
+#define LUA_COMPAT_5_1
+
 extern "C" {
 #include "lua.h"
 #include "lualib.h"
 #include "lauxlib.h"
 }
 
+		#define LUA_GLOBALSINDEX LUA_RIDX_GLOBALS
+				
 #if defined(_WIN32) && defined(_MSC_VER)
 
 // MSVC looks deeper into the code than other compilers, sees that
@@ -119,11 +125,22 @@
 	lua_error(L);
 }
 
-inline int absolute_index(lua_State *L, int index) {
-	return ((index < 0) && (index != LUA_REGISTRYINDEX) && (index != LUA_GLOBALSINDEX))
-	       ? (lua_gettop(L) + index + 1) : index;
+// lua_absindex for LUA <5.1
+inline int absolute_index(lua_State* L, int index)
+{
+  if (index > LUA_REGISTRYINDEX && index < 0)
+    return lua_gettop (L) + index + 1;
+  else
+    return index;
 }
 
+/** 				
+* merge_table / clone_table / clear_table utilized to
+* "soft-replace" an existing global scope instead of using using new_table,
+* because then startup script would be bound to a different copy 
+* of the globals than the extension script.
+**/
+
 // copy the contents of one table into another returning the size
 static int merge_table(lua_State *L, int destTableIdx, int srcTableIdx, bool copyMetatable = false) {
 	int count = 0;
@@ -1226,36 +1243,44 @@
 }
 
 static void PublishGlobalBufferData() {
-	lua_pushliteral(luaState, "buffer");
+// release 1.62
+// A Lua table called 'buffer' is associated with each buffer
+// and can be used to maintain buffer-specific state.
+	lua_pushliteral(luaState, "buffer"); //object: buffer globalScope 
 	if (curBufferIndex >= 0) {
 		lua_pushliteral(luaState, "SciTE_BufferData_Array");
 		lua_rawget(luaState, LUA_REGISTRYINDEX);
+		// create new SciTE_BufferData_Array
 		if (!lua_istable(luaState, -1)) {
 			lua_pop(luaState, 1);
-
+			// Create new SciTE_BufferData_Array / append to LUA_REGISTRYINDEX
 			lua_newtable(luaState);
 			lua_pushliteral(luaState, "SciTE_BufferData_Array");
 			lua_pushvalue(luaState, -2);
 			lua_rawset(luaState, LUA_REGISTRYINDEX);
 		}
+		//  create new entry for current buffer in SciTE_BufferData_Array(idx) 
 		lua_rawgeti(luaState, -1, curBufferIndex);
 		if (!lua_istable(luaState, -1)) {
-			// create new buffer-data
 			lua_pop(luaState, 1);
 			lua_newtable(luaState);
 			// remember it
 			lua_pushvalue(luaState, -1);
 			lua_rawseti(luaState, -3, curBufferIndex);
 		}
-		// Replace SciTE_BufferData_Array in the stack, leaving (buffer=-1, 'buffer'=-2)
+		// replace SciTE_BufferData_Array on the Stack (Leaving (buffer=-1, 'buffer'=-2))
+		// done to apply the expanded  SciTE_BufferData_Array ? 
+		// FIX_HERE LUA_GLOBALSINDEX
 		lua_replace(luaState, -2);
 	} else {
-		// for example, during startup, before any InitBuffer / ActivateBuffer
+	/// ensure that the luatable "buffer" will be empty during startup and before any InitBuffer / ActivateBuffer
 		lua_pushnil(luaState);
 	}
-	lua_rawset(luaState, LUA_GLOBALSINDEX);
+//	was lua_settable(luaState, LUA_GLOBALSINDEX); //or lua_rawset(luaState, LUA_GLOBALSINDEX);		
+lua_setglobal(luaState, "buffer");
 }
 
+
 static bool InitGlobalScope(bool checkProperties, bool forceReload = false) {
 	bool reload = forceReload;
 	if (checkProperties) {
@@ -1274,10 +1299,13 @@
 		// copy of the initialized global environment, and uses that to re-init the scope.
 
 		if (!reload) {
+		
 			lua_getfield(luaState, LUA_REGISTRYINDEX, "SciTE_InitialState");
 			if (lua_istable(luaState, -1)) {
-				clear_table(luaState, LUA_GLOBALSINDEX, true);
-				merge_table(luaState, LUA_GLOBALSINDEX, -1, true);
+				//FIX_HERE: 2xLUA_GLOBALSINDEX
+				lua_getfield(luaState, LUA_REGISTRYINDEX,"_G");		
+				clear_table(luaState,-1, true);
+				merge_table(luaState, LUA_RIDX_GLOBALS, -1, true);
 				lua_pop(luaState, 1);
 
 				// restore initial package.loaded state
@@ -1293,6 +1321,7 @@
 			} else {
 				lua_pop(luaState, 1);
 			}
+			
 		}
 
 		// reload mode is enabled, or else the initial state has been broken.
@@ -1308,7 +1337,11 @@
 
 		// Don't replace global scope using new_table, because then startup script is
 		// bound to a different copy of the globals than the extension script.
-		clear_table(luaState, LUA_GLOBALSINDEX, true);
+		//FIX_HERE: LUA_GLOBALSINDEX
+		lua_pushglobaltable(luaState);
+		//lua_getfield(luaState, LUA_REGISTRYINDEX,"_G");
+		//lua_rawgeti(luaState, LUA_REGISTRYINDEX,LUA_RIDX_GLOBALS);
+		clear_table(luaState, -1, true);
 
 		// Lua 5.1: _LOADED is in LUA_REGISTRYINDEX, so it must be cleared before
 		// loading libraries or they will not load because Lua's package system
@@ -1317,7 +1350,7 @@
 		lua_setfield(luaState, LUA_REGISTRYINDEX, "_LOADED");
 
 	} else if (!luaDisabled) {
-		luaState = lua_open();
+		luaState = luaL_newstate();
 		if (!luaState) {
 			luaDisabled = true;
 			host->Trace("> Lua: scripting engine failed to initialise\n");
@@ -1404,7 +1437,10 @@
 		lua_pushcfunction(luaState, cf_global_metatable_index);
 		lua_setfield(luaState, -2, "__index");
 	}
-	lua_setmetatable(luaState, LUA_GLOBALSINDEX);
+	//Set above created table as new metatable for globalstable (use LUA_RIDX_GLOBALS ?)
+
+	//lua_setmetatable(luaState, LUA_REGISTRYINDEX);
+	lua_setmetatable(luaState, LUA_RIDX_GLOBALS);
 
 	if (checkProperties && reload) {
 		CheckStartupScript();
@@ -1430,11 +1466,15 @@
 		}
 	}
 
-	// Clone the initial state (including metatable) in the registry so that it can be restored.
+	// Clone the initial (globalsindex) state (including metatable) in the registry so that it can be restored.
 	// (If reset==1 this will not be used, but this is a shallow copy, not very expensive, and
 	// who knows what the value of reset will be the next time InitGlobalScope runs.)
-	clone_table(luaState, LUA_GLOBALSINDEX, true);
+	
+	//FIX_HERE: LUA_GLOBALSINDEX
+	lua_pushglobaltable(luaState);
+	clone_table(luaState, -2, true);
 	lua_setfield(luaState, LUA_REGISTRYINDEX, "SciTE_InitialState");
+	lua_pop(luaState,1);
 
 	// Clone loaded packages (package.loaded) state in the registry so that it can be restored.
 	lua_getfield(luaState, LUA_REGISTRYINDEX, "_LOADED");
@@ -1507,9 +1547,11 @@
 
 
 bool LuaExtension::InitBuffer(int index) {
-	//char msg[100];
-	//sprintf(msg, "InitBuffer(%d)\n", index);
-	//host->Trace(msg);
+	/* 
+	char msg[100];
+	sprintf(msg, "InitBuffer(%d)\n", index);
+	host->Trace(msg);
+	*/
 
 	if (index > maxBufferIndex)
 		maxBufferIndex = index;
@@ -1535,9 +1577,11 @@
 }
 
 bool LuaExtension::ActivateBuffer(int index) {
-	//char msg[100];
-	//sprintf(msg, "ActivateBuffer(%d)\n", index);
-	//host->Trace(msg);
+	/*
+	char msg[100];
+	sprintf(msg, "ActivateBuffer(%d)\n", index);
+	host->Trace(msg);
+	*/
 
 	// Probably don't need to do anything with Lua here.  Setting
 	// curBufferIndex is important so that InitGlobalScope knows
@@ -1586,15 +1630,22 @@
 }
 
 bool LuaExtension::OnExecute(const char *s) {
+// gets called when selecting a luaScript within the tools menu
+// pcalls string.find(s) -> if that succeeds, insert the function onto the stack and try to call_function(s).
 	bool handled = false;
+	std::string msg = "lua: selected Tools->";
+	msg.append(s);
+	msg.append("\n");
+	host->Trace(msg.c_str());
 
 	if (luaState || InitGlobalScope(false)) {
 		// May as well use Lua's pattern matcher to parse the command.
 		// Scintilla's RESearch was the other option.
 		int stackBase = lua_gettop(luaState);
-
+	//FIX_HERE LUA_GLOBALSINDEX	
+	lua_rawgeti(luaState, LUA_REGISTRYINDEX,LUA_RIDX_GLOBALS);
 		lua_pushliteral(luaState, "string");
-		lua_rawget(luaState, LUA_GLOBALSINDEX);
+	lua_rawget(luaState, -2);			
 		if (lua_istable(luaState, -1)) {
 			lua_pushliteral(luaState, "find");
 			lua_rawget(luaState, -2);
@@ -1602,9 +1653,10 @@
 				lua_pushstring(luaState, s);
 				lua_pushliteral(luaState, "^%s*([%a_][%a%d_]*)%s*(.-)%s*$");
 				int status = lua_pcall(luaState, 2, 4, 0);
+		// validate s  ?
 				if (status==0) {
-					lua_insert(luaState, stackBase+1);
-					lua_gettable(luaState, LUA_GLOBALSINDEX);
+			lua_insert(luaState, stackBase+1);	//function	
+			lua_getglobal(luaState,(s));	// functionName
 					if (!lua_isnil(luaState, -1)) {
 						if (lua_isfunction(luaState, -1)) {
 							// Try calling it and, even if it fails, short-circuit Filerx
@@ -1623,7 +1675,7 @@
 		} else {
 			host->Trace("> Lua: string library not loaded\n");
 		}
-
+/**/
 		lua_settop(luaState, stackBase);
 	}
 
