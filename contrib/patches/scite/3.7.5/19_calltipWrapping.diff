// Automatic linewrap SciTe's Calltips -> beta todo: More Testing / add some steering vars.   
diff -Nurw scite/src/SciTEBase.cxx scite_mod/src/SciTEBase.cxx
--- scite/src/SciTEBase.cxx	2017-05-26 00:25:03.000000000 +0200
+++ scite_mod/src/SciTEBase.cxx	2018-10-30 13:36:16.995554800 +0100
@@ -1497,6 +1497,83 @@
 	return words;
 }
 
+unsigned int SciTEBase::parseFunctionDefinition(std::string text, unsigned int partNo) {
+/* 
+		Returns positions of parts within an api entry. ( params / funcs Documentation )
+		coops with subfunctions() within the funcs definition.
+*/
+
+unsigned int pos=0;
+unsigned int brackets=0;
+unsigned int marker=0;
+
+    while (pos < text.size()){ 
+			if (text[pos]==(int)calltipParametersStart.c_str()) {
+					brackets++ ;
+					marker=1;
+          if (marker==1 && partNo==1 ) return pos-1; // start functions params				
+			} else if (text[pos]==(int)calltipParametersEnd.c_str() && brackets>0){
+					brackets--;
+			} else if (brackets==0 && marker==1) {
+					marker=2; 
+					if (partNo==2) return pos; // end functions params
+			} else if (marker==2 && (isspace(text[pos]))) {
+					if (partNo==3) return pos; // start functions Description
+					marker=3;
+			} else if (marker>=2 && pos==text.size()-1 ) {
+					return pos; // eol
+			}
+			pos++;
+
+    }
+
+    return(0);
+}
+
+
+std::string SciTEBase::wrapText(std::string text, unsigned per_line) {
+/*	Submitted by Sean Hubbard on https://www.cprogramming.com/snippets/source-code/word-wrap-in-c
+		This function takes a string and an output buffer and a desired width. It then copies 
+		the string to the buffer, inserting a new line character when a certain line
+		length is reached.  If the end of the line is in the middle of a word, it will
+		backtrack along the string until white space is found.
+*/	 
+
+    unsigned line_begin = 0;
+
+    while (line_begin < text.size())
+    {
+        const unsigned ideal_end = line_begin + per_line ;
+        unsigned line_end = ideal_end <= text.size() ? ideal_end : text.size()-1;
+
+        if (line_end == text.size() - 1)
+            ++line_end;
+        else if (isspace(text[line_end]))
+        {
+            text[line_end] = '\n';
+            ++line_end;
+        }
+        else    // backtrack current word
+        {
+            unsigned end = line_end;
+            while ( end > line_begin && !isspace(text[end]))
+                --end;
+
+            if (end != line_begin)                  
+            {                                       
+                line_end = end;                     
+                text[line_end++] = '\n';            
+            }                                       
+            else                                 
+                text.insert(line_end++, 1, '\n');
+        }
+
+        line_begin = line_end;
+    }
+
+    return text;
+}
+
 void SciTEBase::FillFunctionDefinition(int pos /*= -1*/) {
 	if (pos > 0) {
 		lastPosCallTip = pos;
@@ -1512,14 +1589,42 @@
 		// Should get current api definition
 		std::string word = apis.GetNearestWord(currentCallTipWord.c_str(), currentCallTipWord.length(),
 		        callTipIgnoreCase, calltipWordCharacters, currentCallTip);
+					
+		// lineWrap that functions Api Documentation
 		if (word.length()) {
-			functionDefinition = word;
+
+			unsigned int docSep=parseFunctionDefinition(word,3); // get Function Description
+			unsigned int wrapPos;
+			unsigned int maxOneLiner=111; // do not linewrap below that size
+			unsigned int minWrapPos=80; // minimum / maximum linewrap size to use.
+			unsigned int maxWrapPos=140;
+			
+			std::string funcDescr= word.substr(0,docSep);
+			std::string funcDocs = word.substr(docSep, std::string::npos);
+			
+			if (funcDescr.size()>0)
+				functionDefinition=funcDescr;
+			
+			if (funcDocs.size()<maxOneLiner) {
+					wrapPos=funcDocs.size()+1;
+			} else {
+				wrapPos=(funcDescr.size()<minWrapPos)?minWrapPos:funcDescr.size();
+				//  move smaller chunks back to the previous lines.  		
+					unsigned int lineRest;
+					std::string strTmp = std::to_string((funcDocs.size()*100 / wrapPos*100)/100);
+					lineRest=std::stoi(strTmp.substr(strTmp.size()-2,std::string::npos));
+					if (lineRest<36) wrapPos+=lineRest;
+			}
+			
+			wrapPos=(wrapPos<maxWrapPos)?wrapPos:maxWrapPos;
+			functionDefinition+= wrapText(funcDocs, wrapPos);		
+					
 			if (maxCallTips > 1) {
 				functionDefinition.insert(0, "\001");
 			}
 
 			if (calltipEndDefinition != "") {
-				size_t posEndDef = functionDefinition.find(calltipEndDefinition.c_str());
+				size_t posEndDef= parseFunctionDefinition(word,2)-1; // fix constructs aka fn(p1,p2=z.(),p3)
 				if (maxCallTips > 1) {
 					if (posEndDef != std::string::npos) {
 						functionDefinition.insert(posEndDef + calltipEndDefinition.length(), "\n\002");
diff -Nurw scite/src/SciTEBase.h scite_mod/src/SciTEBase.h
--- scite/src/SciTEBase.h	2017-05-26 00:25:03.000000000 +0200
+++ scite_mod/src/SciTEBase.h	2018-10-30 13:27:53.313200700 +0100
@@ -757,6 +757,8 @@
 	void ShowMessages(int line);
 	void GoMessage(int dir);
 	virtual bool StartCallTip();
+	unsigned int parseFunctionDefinition(std::string text, unsigned int partNo);
+	std::string wrapText(std::string text, unsigned per_line);
 	std::string GetNearestWords(const char *wordStart, size_t searchLen,
 		const char *separators, bool ignoreCase=false, bool exactLen=false);
 	virtual void FillFunctionDefinition(int pos = -1);
