##
# CPP11 API , ordered by header. / fetched from CPlusPlus.com / Februar2017, Marcedo@HabmalneFrage.de | https://sourceforge.net/projects/scite-webdev
##

#[<algorithm>]
adjacent_find(first, last)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find equal adjacent elements in range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
binary_search(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Test if value exists in sorted sequence (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
copy_backward(first, last)Param: (Bidirectional iterators to the initial and final positions in a sequence to be copied.)\t\nDesc: Copy range of elements backward (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
count(InputIterator first, InputIterator last, const T& val)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Count appearances of value in range (function template)\t\nProto: template <class InputIterator, class T>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count (InputIterator first, InputIterator last, const T& val);\t\n|[cpp98 cpp11]|[<algorithm>]
count(InputIterator first, InputIterator last, const T& val)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Count appearances of value in range (function template)\t\nProto: template <class InputIterator, class T>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count (InputIterator first, InputIterator last, const T& val);\t\n|[cpp98 cpp11]|[<algorithm>]
count_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Return number of elements in range satisfying condition (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n|[cpp98 cpp11]|[<algorithm>]
count_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Return number of elements in range satisfying condition (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n|[cpp98 cpp11]|[<algorithm>]
equal_range(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Get subrange of equal elements (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
fill_n(OutputIterator first, Size n, const T& val)Param: (Output iterators to the initial position in a sequence of at least n elements that support being assigned a value of type T.)\t\nDesc: Fill sequence with value (function template)\t\nProto: template <class OutputIterator, class Size, class T> void fill_n (OutputIterator first, Size n, const T& val);\t\n|[cpp98 cpp11]|[<algorithm>]
find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find last subsequence in range (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2> ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);\t\n|[cpp98 cpp11]|[<algorithm>]
find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,  ForwardIterator2 first2, ForwardIterator2 last2)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find element from set in range (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2> ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,  ForwardIterator2 first2, ForwardIterator2 last2);\t\n|[cpp98 cpp11]|[<algorithm>]
find_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Find element in range (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\n InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n|[cpp98 cpp11]|[<algorithm>]
for_each(InputIterator first, InputIterator last, Function fn)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Apply function to range (function template)\t\nProto: template <class InputIterator, class Function> Function for_each (InputIterator first, InputIterator last, Function fn);\t\n|[cpp98 cpp11]|[<algorithm>]
generate(ForwardIterator first, ForwardIterator last, Generator gen)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Generate values for range with function (function template)\t\nProto: template <class ForwardIterator, class Generator>\t\nvoid generate (ForwardIterator first, ForwardIterator last, Generator gen);\t\n|[cpp98 cpp11]|[<algorithm>]
generate_n(OutputIterator first, Size n, Generator gen)Param: (Output iterators to the initial positions in a sequence of at least n elements that support being assigned a value of the type returned by gen.)\t\nDesc: Generate values for sequence with function (function template)\t\nProto: template <class OutputIterator, class Size, class Generator> void generate_n (OutputIterator first, Size n, Generator gen);\t\n|[cpp98 cpp11]|[<algorithm>]
includes(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence (which is tested on whether it contains the second sequence).)\t\nDesc: Test whether sorted range includes another sorted range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
inplace_merge(first)Param: (Bidirectional iterator to the initial position in the first sorted sequence to merge.)\t\nDesc: Merge consecutive sorted ranges (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
iter_swap(ForwardIterator1 a, ForwardIterator2 b)Param: (Forward iterators to the objects to swap.)\t\nDesc: Exchange values of objects pointed to by two iterators (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2>\t\nvoid iter_swap (ForwardIterator1 a, ForwardIterator2 b);\t\n|[cpp98 cpp11]|[<algorithm>]
lexicographical_compare(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Lexicographical less-than comparison (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
lower_bound(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Return iterator to lower bound (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
make_heap(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be transformed into a heap.)\t\nDesc: Make heap from range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
max_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return largest element in range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
min_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return smallest element in range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
mismatch(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Return first position where two ranges differ (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
next_permutation(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence.)\t\nDesc: Transform range to next permutation (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
nth_element(RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last)Param: (Random-access iterators to the initial and final positions of the sequence to be used.)\t\nDesc: Sort element in range (function template)\t\nProto: template <class RandomAccessIterator> void nth_element (RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last);\t\n|[cpp98 cpp11]|[<algorithm>]
partial_sort(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be partially sorted.)\t\nDesc: Partially sort elements in range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
partial_sort_copy(first, last)Param: (Input iterators to the initial and final positions of the sequence to copy from.)\t\nDesc: Copy and partially sort range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
partition()Param:\t\Desc: Partially sort elements in range)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
partition_copy()Param:\t\Desc: Copy and partially sort range)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
pop_heap(first, last)Param: (Random-access iterators to the initial and final positions of the heap to be shrank by one.)\t\nDesc: Pop element from heap range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
prev_permutation(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence.)\t\nDesc: Transform range to previous permutation (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
push_heap(first, last)Param: (Random-access iterators to the initial and final positions of the new heap range, including the pushed element.)\t\nDesc: Push element into heap range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
random_shuffle(RandomAccessIterator first, RandomAccessIterator last)Param: (Random-access iterators to the initial and final positions of the sequence to be shuffled.)\t\nDesc: Randomly rearrange elements in range (function template)\t\nProto: template <class RandomAccessIterator> void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);\t\n|[cpp98 cpp11]|[<algorithm>]
remove_copy(InputIterator first, InputIterator last,  OutputIterator result, const T& val)Param: (Forward iterators to the initial and final positions in a sequence of elements supporting being compared to a value of type T.)\t\nDesc: Copy range removing value (function template)\t\nProto: template <class InputIterator, class OutputIterator, class T>\t\nOutputIterator remove_copy (InputIterator first, InputIterator last,  OutputIterator result, const T& val);\t\n|[cpp98 cpp11]|[<algorithm>]
remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range removing values (function template)\t\nProto: template <class InputIterator, class OutputIterator, class UnaryPredicate>\t\nOutputIterator remove_copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);\t\n|[cpp98 cpp11]|[<algorithm>]
remove_if(ForwardIterator first, ForwardIterator last,UnaryPredicate pred)Param: (Forward iterators to the initial and final positions in a sequence of move-assignable elements.)\t\nDesc: Remove elements from range (function template)\t\nProto: template <class ForwardIterator, class UnaryPredicate> ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,UnaryPredicate pred);\t\n|[cpp98 cpp11]|[<algorithm>]
replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)Param: (Forward iterators to the initial and final positions in a sequence of elements that support being compared and assigned a value of type T.)\t\nDesc: Replace value in range (function template)\t\nProto: template <class ForwardIterator, class T>\t\nvoid replace (ForwardIterator first, ForwardIterator last,  const T& old_value, const T& new_value);\t\n|[cpp98 cpp11]|[<algorithm>]
replace_copy(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range replacing value (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
replace_copy_if(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range replacing value (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T& new_value )Param: (Forward iterators to the initial and final positions in a sequence of elements that support being assigned a value of type T.)\t\nDesc: Replace values in range (function template)\t\nProto: template <class ForwardIterator, class UnaryPredicate, class T>\t\nvoid replace_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T& new_value );\t\n|[cpp98 cpp11]|[<algorithm>]
reverse(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to be reversed.)\t\nDesc: Reverse range (function template)\t\nProto: template <class BidirectionalIterator>\t\nvoid reverse (BidirectionalIterator first, BidirectionalIterator last);\t\n|[cpp98 cpp11]|[<algorithm>]
reverse_copy(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to be copied.)\t\nDesc: Copy range reversed (function template)\t\nProto: template <class BidirectionalIterator, class OutputIterator>\t\nOutputIterator reverse_copy (BidirectionalIterator first,  BidirectionalIterator last, OutputIterator result);\t\n|[cpp98 cpp11]|[<algorithm>]
rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last)Param: (Forward iterators to the initial and final positions of the sequence to be rotated left.)\t\nDesc: Rotate left the elements in range (function template)\t\nProto: template <class ForwardIterator> void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last);\t\n|[cpp98 cpp11]|[<algorithm>]
rotate_copy(ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result)Param: (Forward iterators to the initial and final positions of the range to be copy-rotated.)\t\nDesc: Copy range rotated left (function template)\t\nProto: template <class ForwardIterator, class OutputIterator>\t\nOutputIterator rotate_copy (ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result);\t\n|[cpp98 cpp11]|[<algorithm>]
search_n(first, last)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Search range for elements (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
set_difference(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Difference of two sorted ranges (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
set_intersection(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Intersection of two sorted ranges (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
set_symmetric_difference(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Symmetric difference of two sorted ranges (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
set_union(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Union of two sorted ranges (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
sort_heap(first, last)Param: (Random-access iterators to the initial and final positions of the heap range to be sorted.)\t\nDesc: Sort elements of heap (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
stable_partition(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to partition.)\t\nDesc: Partition range in two - stable ordering (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
stable_sort(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be sorted.)\t\nDesc: Sort elements preserving order of equivalents (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2)Param: (Forward iterators to the initial and final positions in one of the sequences to be swapped.)\t\nDesc: Exchange values of two ranges (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2>\t\nForwardIterator2 swap_ranges (ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2);\t\n|[cpp98 cpp11]|[<algorithm>]
transform(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Transform range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
unique_copy(first, last)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range removing duplicates (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]
upper_bound(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Return iterator to upper bound (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<algorithm>]

#[<atomic>]	
ATOMIC_FLAG_INIT()Param: ()\t\nDesc: Initialization of atomic flag (macro)\t\nProto: ATOMIC_FLAG_INIT\t\n[cpp11]|[<atomic>]
ATOMIC_VAR_INIT(val)Param: (Value to use for initialization.)\t\nDesc: Initialization of atomic variable (macro)\t\nProto: ATOMIC_VAR_INIT(val)\t\n[cpp11]|[<atomic>]

#[<bitset>]
bitset(N)Param: (Size of the bitset, in terms of number of bits.)\t\nDesc: Bitset (class template)\t\nProto: template <size_t N> class bitset;\t\n|[cpp98 cpp11 ]|[<bitset>]

#[<cmath>]
float_t()Param: ()\t\nDesc: Floating-point type (type)\t\nProto: no-proto\t\n|[cpp99 cpp11]|[<cmath> (math.h)]
NAN()Param: ()\t\nDesc: Not-A-Number (constant)\t\nProto: float\t\n|[cpp99 cpp11]|[<cmath> (math.h)]

#[<complex>]		
complex(T)Param: (Type of both the real and imaginary components of the complex number.)\t\nDesc: Complex number class (class template)\t\nProto: template <class T> class complex;\t\n|[cpp98 cpp11 ]|[<complex>]
conj(const complex<T>& x)Param: (Complex value.)\t\nDesc: Complex conjugate (function template)\t\nProto: template<class T> complex<T> conj (const complex<T>& x);\t\n|[cpp98 cpp11]|[<complex>]
imag(const complex<T>& x)Param: (Complex value.)\t\nDesc: Imaginary part of complex (function template)\t\nProto: template<class T> T imag (const complex<T>& x);\t\n|[cpp98 cpp11]|[<complex>]
polar(const T& rho, const T& theta = 0)Param: (Magnitude (modulus) of the complex number.)\t\nDesc: Complex from polar components (function template)\t\nProto: template<class T> complex<T> polar (const T& rho, const T& theta = 0);\t\n|[cpp98 cpp11]|[<complex>]
proj(const complex<T>& x)Param: (Complex value.)\t\nDesc: Complex projection. (function template)\t\nProto: template<class T> complex<T> proj (const complex<T>& x);\t\n|[cpp11]|[<complex>]

#[<condition_variable>]
condition_variable()Param: ()\t\nDesc: Condition variable (class)\t\nProto: class condition_variable;\t\n|[cpp11 ]|[<condition_variable>]
condition_variable_any()Param: ()\t\nDesc: Condition variable (any lock) (class)\t\nProto: class condition_variable_any;\t\n|[cpp11 ]|[<condition_variable>]
cv_status()Param: ()\t\nDesc: Condition variable status (enum class)\t\nProto: enum class cv_status;\t\n|[cpp11]|[<condition_variable>]
notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lck)Param: (A condition_variable object to notify all at thread exit.)\t\nDesc: Notify all at thread exit (function)\t\nProto: void notify_all_at_thread_exit (condition_variable& cond, unique_lock<mutex> lck);\t\n|[cpp11]|[<condition_variable>]

#[<cstddef>]
max_align_t()Param: ()\t\nDesc: Type with widest scalar alignment (type)\t\nProto: no-proto\t\n|[cpp11]|[<cstddef> (stddef.h)]
nullptr_t(nullptr);Param: ()\t\nDesc: Null pointer type (C++) (type)\t\nProto: typedef decltype(nullptr) nullptr_t;\t\n|[cpp11]|[<cstddef> (stddef.h)]

#[<deque>]	
deque(T)Param: (Type of the elements.)\t\nDesc: Double ended queue (class template)\t\nProto: template < class T, class Alloc = allocator<T> > class deque;\t\n|[cpp98 cpp11 ]|[<deque>]

#[<exception>]
bad_exception()Param: ()\t\nDesc: Exception thrown by unexpected handler (class)\t\nProto: class bad_exception;\t\n|[cpp98 cpp11]|[<exception>]
current_exception( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get smart pointer to current exception (function)\t\nProto: exception_ptr current_exception() noexcept;\t\n|[cpp11]|[<exception>]
get_terminate( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get terminate handler function (function)\t\nProto: terminate_handler get_terminate() noexcept;\t\n|[cpp11]|[<exception>]
get_unexpected( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get unexpected handler function (function)\t\nProto: unexpected_handler get_unexpected() noexcept;\t\n|[cpp11]|[<exception>]
make_exception_ptr(E e)Param: (An object or reference.)\t\nDesc: Make exception_ptr (function template)\t\nProto: template <class E>\t\nexception_ptr make_exception_ptr (E e) noexcept;\t\n|[cpp11]|[<exception>]
nested_exception()Param: ()\t\nDesc: Nested exception class (class)\t\nProto: class nested_exception;\t\n|[cpp11 ]|[<exception>]
rethrow_exception(exception_ptr p)Param: (An exception_ptr object pointing to an exception object.)\t\nDesc: Rethrow exception (function)\t\nProto: |[cpp11]|[<exception>]
rethrow_if_nested(const T& e)Param: (An object or reference.)\t\nDesc: Rethrow if nested (function)\t\nProto: template <class T>\t\nvoid rethrow_if_nested (const T& e);\t\n|[cpp11]|[<exception>]
set_terminate(terminate_handler f)Param: (Function that takes no parameters and returns no value ()\t\nDesc: Set terminate handler function (function)\t\nProto: terminate_handler set_terminate (terminate_handler f) throw();\t\n|[cpp98 cpp11]|[<exception>]
set_unexpected(unexpected_handler f)Param: (Function that takes no parameters and returns no value ()\t\nDesc: Set unexpected handler function (function)\t\nProto: unexpected_handler set_unexpected (unexpected_handler f) throw();\t\n|[cpp98 cpp11]|[<exception>]
terminate_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Type of terminate handler function (type)\t\nProto: typedef void (*terminate_handler)();\t\n|[cpp98 cpp11]|[<exception>]
throw_with_nested(T&& e)Param: (An object or reference of a non-union class not derived from nested_exception.)\t\nDesc: Throw with nested (function)\t\nProto: |[cpp11]|[<exception>]
uncaught_exception( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return exception status (function)\t\nProto: bool uncaught_exception() throw();\t\n|[cpp98 cpp11]|[<exception>]
unexpected_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Type of unexpected handler function (type)\t\nProto: typedef void (*unexpected_handler)();\t\n|[cpp98 cpp11]|[<exception>]

[<forward_list>]	
forward_list(T)Param: (Type of the elements.)\t\nDesc: Forward list (class template)\t\nProto: template < class T, class Alloc = allocator<T> > class forward_list;\t\n|[cpp11 ]|[<forward_list>]

#[<fstream>]	
basic_filebuf(charT)Param: (Character type.)\t\nDesc: File stream buffer (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_filebuf;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_filebuf(charT)Param: (Character type.)\t\nDesc: File stream buffer (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_filebuf;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_fstream(charT)Param: (Character type.)\t\nDesc: File stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_fstream;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_fstream(charT)Param: (Character type.)\t\nDesc: File stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_fstream;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_ifstream(charT)Param: (Character type.)\t\nDesc: Input file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ifstream;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_ifstream(charT)Param: (Character type.)\t\nDesc: Input file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ifstream;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_ofstream(charT)Param: (Character type.)\t\nDesc: Output file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ofstream;\t\n|[cpp98 cpp11 ]|[<fstream>]
basic_ofstream(charT)Param: (Character type.)\t\nDesc: Output file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ofstream;\t\n|[cpp98 cpp11 ]|[<fstream>]
wfilebuf()Param: ()\t\nDesc: File stream buffer (wide) (class)\t\nProto: typedef basic_filebuf<wchar_t> wfilebuf;\t\n|[cpp98 cpp11]|[<fstream>]
wfstream()Param: ()\t\nDesc: File stream (wide) (class)\t\nProto: typedef basic_fstream<wchar_t> wfstream;\t\n|[cpp98 cpp11]|[<fstream>]
wifstream()Param: ()\t\nDesc: Input file stream (wide) (class)\t\nProto: typedef basic_ifstream<wchar_t> wifstream;\t\n|[cpp98 cpp11]|[<fstream>]
wofstream()Param: ()\t\nDesc: Output file stream (wide) (class)\t\nProto: typedef basic_ofstream<wchar_t> wofstream;\t\n|[cpp98 cpp11]|[<fstream>]

#[<functional>]	
bad_function_call()Param: ()\t\nDesc: Exception thrown on bad call (class)\t\nProto: class bad_function_call;\t\n|[cpp11]|[<functional>]
binary_function()Param: ()\t\nDesc: Binary function object base class (class template)\t\nProto: template <class Arg1, class Arg2, class Result> struct binary_function;\t\n|[cpp98 cpp11]|[<functional>]
binary_negate(Predicate)Param: (A binary function object class, with members first_argument_type and second_argument_type defined.)\t\nDesc: Negate binary function object class (class template)\t\nProto: template <class Predicate> class binary_negate;\t\n|[cpp98 cpp11]|[<functional>]
bind(fn)Param: (A function object, pointer to function or pointer to member.)\t\nDesc: Bind function arguments (function template)\t\nProto: long-proto\t\n|[cpp11]|[<functional>]
bind1st(const Operation& op, const T& x)Param: ()\t\nDesc: Return function object with first parameter bound (function template)\t\nProto: template <class Operation, class T>\t\nbinder1st<Operation> bind1st (const Operation& op, const T& x);\t\n|[cpp98 cpp11]|[<functional>]
bind2nd(const Operation& op, const T& x)Param: ()\t\nDesc: Return function object with second parameter bound (function template)\t\nProto: template <class Operation, class T>\t\nbinder2nd<Operation> bind2nd (const Operation& op, const T& x);\t\n|[cpp98 cpp11]|[<functional>]
binder1st()Param: ()\t\nDesc: Generate function object class with 1st parameter bound (class template)\t\nProto: template <class Operation> class binder1st;\t\n|[cpp98 cpp11]|[<functional>]
binder2nd()Param: ()\t\nDesc: Generate function object class with 2nd parameter bound (class template)\t\nProto: template <class Operation> class binder2nd;\t\n|[cpp98 cpp11]|[<functional>]
bit_and(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise AND function object class (class template)\t\nProto: template <class T> struct bit_and;\t\n|[cpp11]|[<functional>]
bit_xor(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise XOR function object class (class template)\t\nProto: template <class T> struct bit_xor;\t\n|[cpp11]|[<functional>]
const_mem_fun1_ref_t()Param: ()\t\nDesc: Generate function object class from single-parameter const member (reference version) (class template)\t\nProto: template <class S, class T, class A> class const_mem_fun1_ref_t;\t\n|[cpp98 cpp11]|[<functional>]
const_mem_fun1_t()Param: ()\t\nDesc: Generate function object class from single-parameter const member (pointer version) (class template)\t\nProto: template <class S, class T, class A> class const_mem_fun1_t;\t\n|[cpp98 cpp11]|[<functional>]
const_mem_fun_ref_t()Param: ()\t\nDesc: Generate function object class from const parameterless member (reference version) (class template)\t\nProto: template <class S, class T> class const_mem_fun_ref_t;\t\n|[cpp98 cpp11]|[<functional>]
const_mem_fun_t()Param: ()\t\nDesc: Generate function object class from const parameterless member (pointer version) (class template)\t\nProto: template <class S, class T> class const_mem_fun_t;\t\n|[cpp98 cpp11]|[<functional>]
cref(elem)Param: (An lvalue reference, whose const reference is stored in the object.)\t\nDesc: Construct reference_wrapper to const (function template)\t\nProto: long-proto\t\n|[cpp11]|[<functional>]
divides(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Division function object class (class template)\t\nProto: template <class T> struct divides;\t\n|[cpp98 cpp11]|[<functional>]
equal_to(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for equality comparison (class template)\t\nProto: template <class T> struct equal_to;\t\n|[cpp98 cpp11]|[<functional>]
function(T)Param: (A type.)\t\nDesc: Function wrapper (class template)\t\nProto: template <class T> function; \t\n|[cpp11 ]|[<functional>]
greater_equal(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for greater-than-or-equal-to comparison (class template)\t\nProto: template <class T> struct greater_equal;\t\n|[cpp98 cpp11]|[<functional>]
hash()Param: ()\t\nDesc: Default hash function object class (class template)\t\nProto: template <class T> struct hash;\t\n|[cpp11]|[<functional>]
is_bind_expression(T)Param: (A type.)\t\nDesc: Is bind expression (class template)\t\nProto: template <class T> struct is_bind_expression;\t\n|[cpp11]|[<functional>]
is_placeholder(T)Param: (A type.)\t\nDesc: Is placeholder (class template)\t\nProto: template <class T> struct is_placeholder;\t\n|[cpp11]|[<functional>]
less_equal(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for less-than-or-equal-to comparison (class template)\t\nProto: template <class T> struct less_equal;\t\n|[cpp98 cpp11]|[<functional>]
logical_and(T)Param: (Type of the arguments passed to the functional call.)\t\nDesc: Logical AND function object class (class template)\t\nProto: template <class T> struct logical_and;\t\n|[cpp98 cpp11]|[<functional>]
logical_not(T)Param: (Type of the argument passed to the functional call.)\t\nDesc: Logical NOT function object class (class template)\t\nProto: template <class T> struct logical_not;\t\n|[cpp98 cpp11]|[<functional>]
mem_fn(Ret T::* pm)Param: (Pointer to a member function.)\t\nDesc: Convert member function to function object (function template)\t\nProto: template <class Ret, class T>\t\n/* unspecified */ mem_fn (Ret T::* pm);\t\n|[cpp11]|[<functional>]
minus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Subtraction function object class (class template)\t\nProto: template <class T> struct minus;\t\n|[cpp98 cpp11]|[<functional>]
modulus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Modulus function object class (class template)\t\nProto: template <class T> struct modulus;\t\n|[cpp98 cpp11]|[<functional>]
multiplies(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Multiplication function object class (class template)\t\nProto: template <class T> struct multiplies;\t\n|[cpp98 cpp11]|[<functional>]
not1(const Predicate& pred)Param: (Unary function object of a class type with member argument_type defined.)\t\nDesc: Return negation of unary function object (function template)\t\nProto: template <class Predicate>\t\nunary_negate<Predicate> not1 (const Predicate& pred);\t\n|[cpp98 cpp11]|[<functional>]
not2(const Predicate& pred)Param: (Binary function object derived from binary_function.)\t\nDesc: Return negation of binary function object (function template)\t\nProto: template <class Predicate>\t\nbinary_negate<Predicate> not2 (const Predicate& pred);\t\n|[cpp98 cpp11]|[<functional>]
not_equal_to(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for non-equality comparison (class template)\t\nProto: template <class T> struct not_equal_to;\t\n|[cpp98 cpp11]|[<functional>]
placeholders()Param: ()\t\nDesc: Bind argument placeholders (namespace)\t\nProto: namespace placeholders {\t\nextern /* unspecified */ _1;extern /* unspecified */ _2;extern /* unspecified */ _3;// ...\t\n}\t\n|[cpp11]|[<functional>]
plus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Addition function object class (class template)\t\nProto: template <class T> struct plus;\t\n|[cpp98 cpp11]|[<functional>]
pointer_to_binary_function()Param: ()\t\nDesc: Generate binary function object class from pointer (class template)\t\nProto: template <class Arg1, class Arg2, class Result> class pointer_to_binary_function;\t\n|[cpp98 cpp11]|[<functional>]
pointer_to_unary_function()Param: ()\t\nDesc: Generate unary function object class from pointer (class template)\t\nProto: template <class Arg, class Result> class pointer_to_unary_function;\t\n|[cpp98 cpp11]|[<functional>]
ptr_fun()Param: ()\t\nDesc: Convert function pointer to function object (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<functional>]
reference_wrapper(T)Param: (Type of the referred element.)\t\nDesc: Reference wrapper (class template)\t\nProto: template <class T> class reference_wrapper;\t\n|[cpp11 ]|[<functional>]
unary_negate(Predicate)Param: (A unary function object class, with member argument_type defined.)\t\nDesc: Negate unary function object class (class template)\t\nProto: template <class Predicate> class unary_negate;\t\n|[cpp98 cpp11]|[<functional>]

#[<future>]	
future()Param: ()\t\nDesc: Future (class template)\t\nProto: template <class T> future;template <class R&> future<R&>; \t\n|[cpp11 ]|[<future>]
future_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return future category (function)\t\nProto: const error_category& future_category() noexcept;\t\n|[cpp11]|[<future>]
future_errc()Param: ()\t\nDesc: Error conditions for future objects (enum class)\t\nProto: enum class future_errc;\t\n|[cpp11 ]|[<future>]
future_error()Param: ()\t\nDesc: Future error exception (class)\t\nProto: class future_error : public logic_error;\t\n|[cpp11 ]|[<future>]
future_status()Param: ()\t\nDesc: Return value for timed future operations (enum class)\t\nProto: enum class future_status;\t\n|[cpp11]|[<future>]
launch()Param: ()\t\nDesc: Launching policy for async (enum class)\t\nProto: enum class launch;\t\n|[cpp11]|[<future>]
packaged_task()Param: ()\t\nDesc: Packaged task (class template)\t\nProto: template <class T> packaged_task;\t\n|[cpp11 ]|[<future>]
promise()Param: ()\t\nDesc: Promise (class template)\t\nProto: template <class T> promise;template <class R&> promise<R&>; \t\n|[cpp11 ]|[<future>]
shared_future()Param: ()\t\nDesc: Shared future (class template)\t\nProto: template <class T> shared_future;template <class R&> shared_future<R&>; \t\n|[cpp11 ]|[<future>]

#[<initializer_list>]
initializer_list(T)Param: (Type of the elements.)\t\nDesc: Initializer list (class template)\t\nProto: template<class T> class initializer_list;\t\n|[cpp11 ]|[<initializer_list>]

#[<iomanip>]	
get_money(moneyT& mon, bool intl = false)Param: (Object where the monetary value is stored.)\t\nDesc: Get monetary value (function)\t\nProto: template <class moneyT>\t\n/*unspecified*/ get_money (moneyT& mon, bool intl = false);\t\n|[cpp11]|[<iomanip>]
get_time(struct tm* tmb, const charT* fmt)Param: (Pointer to an object of type struct tm where the time and date information extracted is stored.)\t\nDesc: Get date and time (function)\t\nProto: template <class charT>\t\n/*unspecified*/ get_time (struct tm* tmb, const charT* fmt);\t\n|[cpp11]|[<iomanip>]
put_money(const moneyT& mon, bool intl = false)Param: (Monetary value.)\t\nDesc: Put monetary value (function)\t\nProto: template <class moneyT>\t\n/*unspecified*/ put_money (const moneyT& mon, bool intl = false);\t\n|[cpp11]|[<iomanip>]
put_time(const struct tm* tmb, const charT* fmt)Param: (Pointer to the object of type struct tm with the date and time information to format.)\t\nDesc: Put date and time (function)\t\nProto: template <class charT>\t\n/*unspecified*/ put_time (const struct tm* tmb, const charT* fmt);\t\n|[cpp11]|[<iomanip>]
resetiosflags(ios_base::fmtflags mask)Param: (Mask representing the flags to be reset.)\t\nDesc: Reset format flags (function)\t\nProto: /*unspecified*/ resetiosflags (ios_base::fmtflags mask);\t\n|[arm cpp98 cpp11]|[<iomanip>]
setbase(int base)Param: (Numerical radix to be used:\t\n\t\nbase argument\t\n\t\nsame as inserting.)\t\nDesc: Set basefield flag (function)\t\nProto: /*unspecified*/ setbase (int base);\t\n|[arm cpp98 cpp11]|[<iomanip>]
setfill(char_type c)Param: (The new fill character for the stream.)\t\nDesc: Set fill character (function)\t\nProto: /*unspecified*/ setfill (char_type c);\t\n|[arm cpp98 cpp11]|[<iomanip>]
setprecision(int n)Param: (New value for the decimal precision.)\t\nDesc: Set decimal precision (function)\t\nProto: /*unspecified*/ setprecision (int n);\t\n|[arm cpp98 cpp11]|[<iomanip>]
setw(int n)Param: (Number of characters to be used as field width.)\t\nDesc: Set field width (function)\t\nProto: /*undefined*/ setw (int n);\t\n|[arm cpp98 cpp11]|[<iomanip>]

#[<ios>]
basic_ios(charT)Param: (Character type.)\t\nDesc: Base class for streams (type-dependent components) (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ios;\t\n|[cpp98 cpp11 ]|[<ios>]
basic_ios(charT)Param: (Character type.)\t\nDesc: Base class for streams (type-dependent components) (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ios;\t\n|[cpp98 cpp11 ]|[<ios>]
boolalpha(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Alphanumerical bool values (function)\t\nProto: ios_base& boolalpha (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
dec(ios_base& str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use decimal base (function)\t\nProto: ios_base& dec (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
defaultfloat(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: no-Description (other)\t\nProto: ios_base& defaultfloat (ios_base& str);\t\n|[cpp11]|[<ios>]
fixed(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: Use fixed floating-point notation (function)\t\nProto: ios_base& fixed (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
hex(ios_base& str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use hexadecimal base (function)\t\nProto: ios_base& hex (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
hexfloat(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: no-Description (other)\t\nProto: ios_base& hexfloat (ios_base& str);\t\n|[cpp11]|[<ios>]
internal(ios_base& str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust field by inserting characters at an internal position (function)\t\nProto: ios_base& internal (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
io_errc()Param: ()\t\nDesc: Input/output error conditions (enum class)\t\nProto: enum class io_errc;\t\n|[cpp11 ]|[<ios>]
ios_base()Param: ()\t\nDesc: Base class for streams (class)\t\nProto: class ios_base;\t\n|[arm cpp98 cpp11 ]|[<ios>]
iostream_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return iostream category (function)\t\nProto: const error_category& iostream_category();\t\n|[cpp11]|[<ios>]
left(ios_base& str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust output to the left (function)\t\nProto: ios_base& left (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
noboolalpha(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: No alphanumerical bool values (function)\t\nProto: ios_base& noboolalpha (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
noshowbase(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show numerical base prefixes (function)\t\nProto: ios_base& noshowbase (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
noshowpoint(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show decimal point (function)\t\nProto: ios_base& noshowpoint (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
noshowpos(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show positive signs (function)\t\nProto: ios_base& noshowpos (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
noskipws(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not skip whitespaces (function)\t\nProto: ios_base& noskipws (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
nounitbuf(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not force flushes after insertions (function)\t\nProto: ios_base& nounitbuf (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
nouppercase(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not generate upper case letters (function)\t\nProto: ios_base& nouppercase (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
oct(ios_base& str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use octal base (function)\t\nProto: ios_base& oct (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
right(ios_base& str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust output to the right (function)\t\nProto: ios_base& right (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
scientific(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: Use scientific floating-point notation (function)\t\nProto: ios_base& scientific (ios_base& str);\t\n|[arm cpp98 cpp11]|[<ios>]
streamoff()Param: ()\t\nDesc: Stream offset type (type)\t\nProto: no-proto\t\n|[arm cpp98 cpp11]|[<ios>]
streampos()Param: ()\t\nDesc: Stream position type (type)\t\nProto: typedef fpos<mbstate_t> streampos;\t\n|[arm cpp98 cpp11]|[<ios>]
streamsize()Param: ()\t\nDesc: Stream size type (type)\t\nProto: no-proto\t\n|[arm cpp98 cpp11]|[<ios>]
wios()Param: ()\t\nDesc: Base class for wide character streams (class)\t\nProto: typedef basic_ios<wchar_t> ios;\t\n|[cpp98 cpp11]|[<ios>]
wstreampos()Param: ()\t\nDesc: Wide stream position type (type)\t\nProto: typedef fpos<mbstate_t> wstreampos;\t\n|[cpp98 cpp11]|[<ios>]

#[<iostream>]
cerr()Param: ()\t\nDesc: Standard output stream for errors (object)\t\nProto: extern ostream cerr;\t\n|[arm cpp98 cpp11]|[<iostream>]
cin()Param: ()\t\nDesc: Standard input stream (object)\t\nProto: extern istream cin;\t\n|[arm cpp98 cpp11]|[<iostream>]
clog()Param: ()\t\nDesc: Standard output stream for logging (object)\t\nProto: extern ostream clog;\t\n|[arm cpp98 cpp11]|[<iostream>]
cout()Param: ()\t\nDesc: Standard output stream (object)\t\nProto: extern ostream cout;\t\n|[arm cpp98 cpp11]|[<iostream>]
wcerr()Param: ()\t\nDesc: Standard output stream for errors (wide-oriented) (object)\t\nProto: extern basic_ostream<wchar_t> wcerr;\t\n|[cpp98 cpp11]|[<iostream>]
wcin()Param: ()\t\nDesc: Standard input stream (wide) (object)\t\nProto: extern basic_istream<wchar_t> wcin;\t\n|[cpp98 cpp11]|[<iostream>]
wclog()Param: ()\t\nDesc: Standard output stream for logging (wide) (object)\t\nProto: extern basic_ostream<wchar_t> wclog;\t\n|[cpp98 cpp11]|[<iostream>]
wcout()Param: ()\t\nDesc: Standard output stream (wide) (object)\t\nProto: extern basic_ostream<wchar_t> wcout;\t\n|[cpp98 cpp11]|[<iostream>]

#[<istream>]
basic_iostream(charT)Param: (Character type.)\t\nDesc: Input/output stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> > class basic_iostream;\t\n|[cpp98 cpp11 ]|[<istream>]
basic_iostream(charT)Param: (Character type.)\t\nDesc: Input/output stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> > class basic_iostream;\t\n|[cpp98 cpp11 ]|[<istream>]
basic_istream(charT)Param: (Character type.)\t\nDesc: Input stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_istream;\t\n|[cpp98 cpp11 ]|[<istream>]
basic_istream(charT)Param: (Character type.)\t\nDesc: Input stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_istream;\t\n|[cpp98 cpp11 ]|[<istream>]
wiostream()Param: ()\t\nDesc: Input/output stream (wide) (class)\t\nProto: typedef basic_iostream<wchar_t> wiostream;\t\n|[arm cpp98 cpp11]|[<istream>]
wistream()Param: ()\t\nDesc: Input stream (wide) (class)\t\nProto: typedef basic_istream<wchar_t> wistream;\t\n|[cpp98 cpp11]|[<istream>]

#[<iterator>]
advance(InputIterator& it, Distance n)Param: (Iterator to be advanced.)\t\nDesc: Advance iterator (function template)\t\nProto: template <class InputIterator, class Distance>\t\nvoid advance (InputIterator& it, Distance n);\t\n|[cpp98 cpp11]|[<iterator>]
back_insert_iterator(Container)Param: (A container class with member push_back defined (such as the standard containers vector, deque and list).)\t\nDesc: Back insert iterator (class template)\t\nProto: template <class Container> class back_insert_iterator;\t\n|[cpp98 cpp11]|[<iterator>]
back_inserter(Container& x)Param: (Container on which the iterator will insert new elements.)\t\nDesc: Construct back insert iterator (function template)\t\nProto: template <class Container>\t\nback_insert_iterator<Container> back_inserter (Container& x);\t\n|[cpp98 cpp11]|[<iterator>]
begin(Container& cont)Param: (An object of a class type for which member begin is defined.)\t\nDesc: Iterator to beginning (function template)\t\nProto: template <class Container> auto begin (Container& cont) -> decltype (cont.begin());template <class Container> auto begin (const Container& cont) -> decltype (cont.begin());\t\n|[cpp11]|[<iterator>]
bidirectional_iterator_tag()Param: ()\t\nDesc: Bidirectional iterator category (class)\t\nProto: struct bidirectional_iterator_tag {}\t\n|[cpp98 cpp11]|[<iterator>]
distance(InputIterator first, InputIterator last)Param: (Iterator pointing to the initial element.)\t\nDesc: Return distance between iterators (function template)\t\nProto: template<class InputIterator>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n distance (InputIterator first, InputIterator last);\t\n|[cpp98 cpp11]|[<iterator>]
distance(InputIterator first, InputIterator last)Param: (Iterator pointing to the initial element.)\t\nDesc: Return distance between iterators (function template)\t\nProto: template<class InputIterator>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n distance (InputIterator first, InputIterator last);\t\n|[cpp98 cpp11]|[<iterator>]
forward_iterator_tag()Param: ()\t\nDesc: Forward iterator category (class)\t\nProto: struct forward_iterator_tag {};\t\n|[cpp98 cpp11]|[<iterator>]
front_insert_iterator(Container)Param: (A container class with member push_front defined (such as the standard containers deque and list).)\t\nDesc: Front insert iterator (class template)\t\nProto: template <class Container> class front_insert_iterator;\t\n|[cpp98 cpp11]|[<iterator>]
front_inserter(Container& x)Param: (Container on which the iterator will insert new elements.)\t\nDesc: Constructs front insert iterator (function template)\t\nProto: template <class Container>\t\nfront_insert_iterator<Container> front_inserter (Container& x);\t\n|[cpp98 cpp11]|[<iterator>]
input_iterator_tag()Param: ()\t\nDesc: Input iterator category (class)\t\nProto: struct input_iterator_tag {};\t\n|[cpp98 cpp11]|[<iterator>]
istream_iterator(T)Param: (Element type for the iterator: The type of elements extracted from the stream.)\t\nDesc: Istream iterator (class template)\t\nProto: template <class T, class charT=char, class traits=char_traits<charT>, \t\n class Distance = ptrdiff_t>\t\nclass istream_iterator;\t\n|[cpp98 cpp11 ]|[<iterator>]
istreambuf_iterator(charT)Param: (Character type.)\t\nDesc: Input stream buffer iterator (class template)\t\nProto: template <class charT, class traits=char_traits<charT> > class istreambuf_iterator;\t\n|[cpp98 cpp11]|[<iterator>]
iterator(Category)Param: (Category to which the iterator belongs to.)\t\nDesc: Iterator base class (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<iterator>]
iterator_traits()Param: ()\t\nDesc: Iterator traits (class template)\t\nProto: template <class Iterator> class iterator_traits;template <class T> class iterator_traits<T*>;template <class T> class iterator_traits<const T*>;\t\n|[cpp98 cpp11]|[<iterator>]
make_move_iterator(const Iterator& it)Param: (An iterator.)\t\nDesc: Construct move iterator (function template)\t\nProto: template <class Iterator> move_iterator<Iterator> make_move_iterator (const Iterator& it);\t\n|[cpp11]|[<iterator>]
ostream_iterator(T)Param: ()\t\nDesc: Ostream iterator (class template)\t\nProto: template <class T, class charT=char, class traits=char_traits<charT> >\t\nclass ostream_iterator;\t\n|[cpp98 cpp11 ]|[<iterator>]
ostreambuf_iterator(charT)Param: (Character type.)\t\nDesc: Output stream buffer iterator (class template)\t\nProto: template <class charT, class traits=char_traits<charT> >\t\nclass ostreambuf_iterator;\t\n|[cpp98 cpp11]|[<iterator>]
output_iterator_tag()Param: ()\t\nDesc: Output iterator category (class)\t\nProto: struct output_iterator_tag {};\t\n|[cpp98 cpp11]|[<iterator>]
random_access_iterator_tag()Param: ()\t\nDesc: Random-access iterator category (class)\t\nProto: struct random_access_iterator_tag {};\t\n|[cpp98 cpp11]|[<iterator>]
reverse_iterator(Iterator)Param: (A bidirectional iterator type.)\t\nDesc: Reverse iterator (class template)\t\nProto: template <class Iterator> class reverse_iterator;\t\n|[cpp98 cpp11 ]|[<iterator>]

#[<limits>]
float_denorm_style()Param: ()\t\nDesc: Enum type for float denormalization style (type)\t\nProto: enum float_denorm_style;\t\n|[cpp98 cpp11]|[<limits>]
float_round_style()Param: ()\t\nDesc: Enum type for float rounding style (type)\t\nProto: enum float_round_style;\t\n|[cpp98 cpp11]|[<limits>]
numeric_limits(T)Param: (A type.)\t\nDesc: Numeric limits type (class template)\t\nProto: template <class T> numeric_limits;\t\n|[cpp98 cpp11]|[<limits>]
has_denorm(float_denorm_style)Denormalized values -representations with a variable number of exponent bits-. A type may have any of the following enum values:[cpp11]|[<limits>]

#[<locale>]
codecvt_base()Param: ()\t\nDesc: Base class for codecvt (class)\t\nProto: class codecvt_base;\t\n|[cpp98 cpp11]|[<locale>]
codecvt_byname()Param: ()\t\nDesc: Convert codeset facet (class template)\t\nProto: template <class internT, class externT, class stateT> class codecvt_byname;\t\n|[cpp98 cpp11]|[<locale>]
collate(charT)Param: (Character type.)\t\nDesc: Facet to compare and hash strings (class template)\t\nProto: template <class charT> class collate;\t\n|[cpp98 cpp11 ]|[<locale>]
collate_byname()Param: ()\t\nDesc: Facet to compare and hash strings (class template)\t\nProto: template <class charT> class collate_byname;\t\n|[cpp98 cpp11]|[<locale>]
ctype_base()Param: ()\t\nDesc: Base class for ctype (class)\t\nProto: class ctype_base;\t\n|[cpp98 cpp11]|[<locale>]
ctype_byname()Param: ()\t\nDesc: Character type facet (class template)\t\nProto: template <class charT> class ctype_byname;\t\n|[cpp98 cpp11]|[<locale>]
has_facet(const locale& loc)Param: (locale object.)\t\nDesc: Check if locale has facet (function template)\t\nProto: template <class Facet> bool has_facet (const locale& loc) throw();\t\n|[cpp98 cpp11]|[<locale>]
messages(charT)Param: (Character type.)\t\nDesc: Facet to access message catalogs (class template)\t\nProto: template <class charT> class messages;\t\n|[cpp98 cpp11 ]|[<locale>]
messages_base()Param: ()\t\nDesc: no-Description\t\nProto: class messages_base;\t\n|[cpp98 cpp11]|[<locale>]
messages_byname()Param: ()\t\nDesc: Facet to access message catalogs (class template)\t\nProto: template <class charT> class messages_byname;\t\n|[cpp98 cpp11]|[<locale>]
money_base()Param: ()\t\nDesc: Base class for moneypunct (class)\t\nProto: class money_base;\t\n|[cpp98 cpp11]|[<locale>]
money_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse monetary expressions (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> >\t\nclass money_get;\t\n|[cpp98 cpp11 ]|[<locale>]
money_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format monetary expressions (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class money_put;\t\n|[cpp98 cpp11 ]|[<locale>]
moneypunct(charT)Param: (Character type.)\t\nDesc: Monetary punctuation facet (class template)\t\nProto: template <class charT, bool International = false> class moneypunct;\t\n|[cpp98 cpp11 ]|[<locale>]
moneypunct_byname()Param: ()\t\nDesc: Monetary punctuation facet (class template)\t\nProto: template <class charT, bool International = false> class numpunct_byname;\t\n|[cpp98 cpp11]|[<locale>]
num_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse numeric values (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> > class num_get;\t\n|[cpp98 cpp11 ]|[<locale>]
num_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format numeric values (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class num_put;\t\n|[cpp98 cpp11 ]|[<locale>]
numpunct(charT)Param: (Character type.)\t\nDesc: Numeric punctuation facet (class template)\t\nProto: template <class charT> class numpunct;\t\n|[cpp98 cpp11 ]|[<locale>]
numpunct_byname()Param: ()\t\nDesc: Numeric puntuation facet (class template)\t\nProto: template <class charT> class numpunct_byname;\t\n|[cpp98 cpp11]|[<locale>]
time_base()Param: ()\t\nDesc: Base class for time_get (class)\t\nProto: class time_base;\t\n|[cpp98 cpp11]|[<locale>]
time_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse dates and times (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> >\t\nclass time_get;\t\n|[cpp98 cpp11 ]|[<locale>]
time_get_byname()Param: ()\t\nDesc: Facet to parse dates and times (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> > class time_get_byname;\t\n|[cpp98 cpp11]|[<locale>]
time_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format dates and times (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> >\t\nclass time_put;\t\n|[cpp98 cpp11 ]|[<locale>]
time_put_byname()Param: ()\t\nDesc: Facet to format dates and times (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class time_put_byname;\t\n|[cpp98 cpp11]|[<locale>]
use_facet(const locale& loc)Param: (locale object.)\t\nDesc: Access facet of locale (function template)\t\nProto: template <class Facet> const Facet& use_facet (const locale& loc);\t\n|[cpp98 cpp11]|[<locale>]
wbuffer_convert(Codecvt)Param: (Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header <codecvt>.)\t\nDesc: no-Description (other)\t\nProto: template < class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem> > class wbuffer_convert\t\n: public std::basic_streambuf<Elem,Tr>;\t\n|[cpp11 ]|[<locale>]
wstring_convert(Codecvt)Param: (Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header <codecvt>.)\t\nDesc: no-Description (other)\t\nProto: template < class Codecvt, class Elem = wchar_t, class Wide_alloc = std::allocator<Elem>, class Byte_alloc = std::allocator<char> > class wstring_convert;\t\n|[cpp11 ]|[<locale>]

#[<map>]	
map(Key)Param: (Type of the keys.)\t\nDesc: Map (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<map>]
multimap(Key)Param: (Type of the keys.)\t\nDesc: Multiple-key map (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<map>]

#[<memory>]	
addressof(T& ref)Param: (An object or function.)\t\nDesc: Address of object or function (function template)\t\nProto: template <class T> T* addressof (T& ref) noexcept;\t\n|[cpp11]|[<memory>]
allocate_shared(const Alloc& alloc, Args&&... args)Param: (An allocator object.)\t\nDesc: Allocate shared_ptr (function template)\t\nProto: template <class T, class Alloc, class... Args>\t\nshared_ptr<T> allocate_shared (const Alloc& alloc, Args&&... args);\t\n|[cpp11]|[<memory>]
allocator(T)Param: (Type of the elements allocated by the object (aliased as member type value_type).)\t\nDesc: Default allocator (class template)\t\nProto: template <class T> class allocator;\t\n|[cpp98 cpp11 ]|[<memory>]
allocator_arg_t()Param: ()\t\nDesc: Allocator arg type (class)\t\nProto: struct allocator_arg_t {};\t\n|[cpp11]|[<memory>]
allocator_traits(Alloc)Param: (The allocator type, aliased as member type allocator_type.)\t\nDesc: Allocator traits (class template)\t\nProto: template <class Alloc> struct allocator_traits;\t\n|[cpp11 ]|[<memory>]
allocator_traits(Alloc)Param: (The allocator type, aliased as member type allocator_type.)\t\nDesc: Allocator traits (class template)\t\nProto: template <class Alloc> struct allocator_traits;\t\n|[cpp11 ]|[<memory>]
auto_ptr(X)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Automatic Pointer [deprecated] (class template)\t\nProto: template <class X> class auto_ptr;\t\n|[cpp98 cpp11 ]|[<memory>]
auto_ptr_ref()Param: ()\t\nDesc: Reference to automatic pointer (class template)\t\nProto: template <class Y> struct auto_ptr_ref;\t\n|[cpp98 cpp11]|[<memory>]
bad_weak_ptr()Param: ()\t\nDesc: no-Description (other)\t\nProto: class bad_weak_ptr: public exception;\t\n|[cpp11 ]|[<memory>]
const_pointer_cast(const shared_ptr<T>& sp)Param: (A shared_pointer.)\t\nDesc: Const cast of shared_ptr (function template)\t\nProto: template <class T, class U>\t\nshared_ptr<T> const_pointer_cast (const shared_ptr<U>& sp) noexcept;\t\n|[cpp11]|[<memory>]
declare_no_pointers(char* p, size_t n)Param: (Pointer to the first byte of the range to be declared.)\t\nDesc: Declare memory block as containing no pointers (function)\t\nProto: void declare_no_pointers (char* p, size_t n);\t\n|[cpp11]|[<memory>]
declare_reachable(void* p)Param: (A safely-derived pointer, or a null pointer.)\t\nDesc: Declare pointer as reachable (function)\t\nProto: void declare_reachable (void* p);\t\n|[cpp11]|[<memory>]
default_delete(T)Param: (The type of object to be deleted.)\t\nDesc: Default deleter (class template)\t\nProto: non-specialized\t\ntemplate <class T> class default_delete;array specialization\t\ntemplate <class T> class default_delete<T|[cpp11 ]|[<memory>]
dynamic_pointer_cast(const shared_ptr<T>& sp)Param: (A shared_ptr.)\t\nDesc: Dynamic cast of shared_ptr (function template)\t\nProto: template <class T, class U>\t\nshared_ptr<T> dynamic_pointer_cast (const shared_ptr<U>& sp) noexcept;\t\n|[cpp11]|[<memory>]
enable_shared_from_this(T)Param: (Full type of the pointed class (generally the final class inheriting from this).)\t\nDesc: Enable shared_from_this (class template)\t\nProto: template <class T> class enable_shared_from_this;\t\n|[cpp11 ]|[<memory>]
get_deleter(const shared_ptr<T>& sp)Param: (A shared_ptr object.)\t\nDesc: Get deleter from shared_ptr (function template)\t\nProto: template <class D, class T>\t\nD* get_deleter (const shared_ptr<T>& sp) noexcept;\t\n|[cpp11]|[<memory>]
get_pointer_safety( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get pointer safety (function)\t\nProto: pointer_safety get_pointer_safety() noexcept;\t\n|[cpp11]|[<memory>]
get_temporary_buffer( ptrdiff_t n )Param: (Number of elements of type T for which temporary memory is requested.)\t\nDesc: Get block of temporary memory (function template)\t\nProto: template <class T> pair <T*,ptrdiff_t> get_temporary_buffer ( ptrdiff_t n );\t\n|[cpp98 cpp11]|[<memory>]
make_shared(Args&&... args)Param: (List of elements passed to T's constructor.)\t\nDesc: Make shared_ptr (function template)\t\nProto: template <class T, class... Args>\t\nshared_ptr<T> make_shared (Args&&... args);\t\n|[cpp11]|[<memory>]
owner_less(Ptr)Param: (The type of the managed pointers to be ordered according to owned resource, aliased as member types first_argument_type and second_argument_type.)\t\nDesc: Owner-based less-than operation (class template)\t\nProto: template <class Ptr> struct owner_less;template <class T> struct owner_less<shared_ptr<T>>;template <class T> struct owner_less<weak_ptr<T>>;\t\n|[cpp11]|[<memory>]
pointer_safety()Param: ()\t\nDesc: Pointer safety enum (enum class)\t\nProto: enum class pointer_safety { relaxed, preferred, strict };\t\n|[cpp11]|[<memory>]
pointer_traits(Ptr)Param: (Pointer-like type.)\t\nDesc: Pointer traits (class template)\t\nProto: template <class Ptr> class pointer_traits; // template\t\ntemplate <class T> class pointer_traits<T*>; // template specialization\t\n|[cpp11 ]|[<memory>]
pointer_traits(Ptr)Param: (Pointer-like type.)\t\nDesc: Pointer traits (class template)\t\nProto: template <class Ptr> class pointer_traits; // template\t\ntemplate <class T> class pointer_traits<T*>; // template specialization\t\n|[cpp11 ]|[<memory>]
raw_storage_iterator(OutputIterator)Param: (Underlying iterator type.)\t\nDesc: Raw storage iterator (class template)\t\nProto: template <class OutputIterator, class T>\t\nclass raw_storage_iterator;\t\n|[cpp98 cpp11]|[<memory>]
return_temporary_buffer(T* p)Param: (Pointer to a block of temporary memory returned by a previous call to get_temporary_buffer.)\t\nDesc: Return block of temporary memory (function template)\t\nProto: template <class T> void return_temporary_buffer (T* p);\t\n|[cpp98 cpp11]|[<memory>]
shared_ptr(T)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Shared pointer (class template)\t\nProto: template <class T> class shared_ptr;\t\n|[cpp11 ]|[<memory>]
static_pointer_cast(const shared_ptr<T>& sp)Param: (A shared_pointer.)\t\nDesc: Static cast of shared_ptr (function template)\t\nProto: template <class T, class U>\t\nshared_ptr<T> static_pointer_cast (const shared_ptr<U>& sp) noexcept;\t\n|[cpp11]|[<memory>]
undeclare_no_pointers(char* p, size_t n)Param: (Pointer to the first byte of the range.)\t\nDesc: Undeclare memory block as containing no pointers (function)\t\nProto: void undeclare_no_pointers (char* p, size_t n);\t\n|[cpp11]|[<memory>]
undeclare_reachable(T* p)Param: (A pointer pointing to an object previously declared as reachable with declare_reachable.)\t\nDesc: Undeclare pointer as reachable (function template)\t\nProto: template <class T> T* undeclare_reachable (T* p);\t\n|[cpp11]|[<memory>]
uninitialized_copy( InputIterator first, InputIterator last, ForwardIterator result )Param: (Input iterators to the initial and final positions in a sequence to be copied.)\t\nDesc: Copy block of memory (function template)\t\nProto: template <class InputIterator, class ForwardIterator>\t\nForwardIterator uninitialized_copy ( InputIterator first, InputIterator last,  ForwardIterator result );\t\n|[cpp98 cpp11]|[<memory>]
uninitialized_copy_n( InputIterator first, Size n,ForwardIterator result )Param: (Forward iterator to the initial position in an uninitialized sequence of at least n elements.)\t\nDesc: Copy block of memory (function template)\t\nProto: template <class InputIterator, class Size, class ForwardIterator>\t\nForwardIterator uninitialized_copy_n ( InputIterator first, Size n,ForwardIterator result );\t\n|[cpp11]|[<memory>]
uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x)Param: (Forward iterators to the initial and final positions in an uninitialized sequence.)\t\nDesc: Fill block of memory (function template)\t\nProto: template <class ForwardIterator, class T>\t\nvoid uninitialized_fill (ForwardIterator first, ForwardIterator last, const T& x);\t\n|[cpp98 cpp11]|[<memory>]
uninitialized_fill_n(ForwardIterator first, Size n, const T& x)Param: (Forward iterator to the initial position in an uninitialized sequence of at least n elements.)\t\nDesc: Fill block of memory (function template)\t\nProto: template <class ForwardIterator, class Size, class T> void uninitialized_fill_n (ForwardIterator first, Size n, const T& x);\t\n|[cpp98 cpp11]|[<memory>]
unique_ptr(T)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Unique pointer (class template)\t\nProto: non-specialized\t\ntemplate <class T, class D = default_delete<T>> class unique_ptr;array specialization\t\ntemplate <class T, class D> class unique_ptr<T|[cpp11 ]|[<memory>]
uses_allocator(T)Param: (A type.)\t\nDesc: no-Description (other)\t\nProto: template <class T, class Alloc> struct uses_allocator;\t\n|[cpp11]|[<memory>]
#[cpp14]
make_unique(Args&&... args)Param: Llist of argumentsto construct an instance of T)\t\nDesc: Make unique (function template)\t\nProto: template <class T, class... Args>\t\nunique_ptr<T> make_unique (Args&&... args);\t\n|[cpp14]|[<memory>]

#[<mutex>]	
adopt_lock_t()Param: ()\t\nDesc: Type of adopt_lock (class)\t\nProto: struct adopt_lock_t {};\t\n|[cpp11]|[<mutex>]
call_once(once_flag& flag, Fn&& fn, Args&&... args)Param: (Object used by the function to track the state of invocations.)\t\nDesc: Call function once (public member function)\t\nProto: template <class Fn, class... Args> void call_once (once_flag& flag, Fn&& fn, Args&&... args);\t\n|[cpp11]|[<mutex>]
defer_lock_t()Param: ()\t\nDesc: Type of defer_lock (class)\t\nProto: struct defer_lock_t {};\t\n|[cpp11]|[<mutex>]
lock_guard(Mutex)Param: (A mutex-like type.)\t\nDesc: Lock guard (class template)\t\nProto: template <class Mutex> class lock_guard;\t\n|[cpp11 ]|[<mutex>]
mutex()Param: ()\t\nDesc: Mutex class (class)\t\nProto: class mutex;\t\n|[cpp11 ]|[<mutex>]
once_flag()Param: ()\t\nDesc: Flag argument type for call_once (class)\t\nProto: struct once_flag;\t\n|[cpp11]|[<mutex>]
recursive_mutex()Param: ()\t\nDesc: Recursive mutex class (class)\t\nProto: class recursive_mutex;\t\n|[cpp11 ]|[<mutex>]
recursive_timed_mutex()Param: ()\t\nDesc: Recursive timed mutex (class)\t\nProto: class recursive_timed_mutex;\t\n|[cpp11 ]|[<mutex>]
try_lock(Mutex1& a, Mutex2& b, Mutexes&... cde)Param: (Objects to try-lock.)\t\nDesc: Try to lock multiple mutexes (function template)\t\nProto: template <class Mutex1, class Mutex2, class... Mutexes>\t\nint try_lock (Mutex1& a, Mutex2& b, Mutexes&... cde);\t\n|[cpp11]|[<mutex>]
try_to_lock_t()Param: ()\t\nDesc: Type of try_to_lock (class)\t\nProto: struct try_to_lock_t {};\t\n|[cpp11]|[<mutex>]
unique_lock(Mutex)Param: (A mutex-like type.)\t\nDesc: Unique lock (class template)\t\nProto: template <class Mutex> class unique_lock;\t\n|[cpp11 ]|[<mutex>]

#[<new>]
bad_alloc()Param: ()\t\nDesc: Exception thrown on failure allocating memory (class)\t\nProto: class bad_alloc;\t\n|[cpp98 cpp11]|[<new>]
bad_array_new_length()Param: ()\t\nDesc: Exception on bad array length (class)\t\nProto: class bad_array_new_length;\t\n|[cpp11]|[<new>]
get_new_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get new handler function (function)\t\nProto: new_handler get_new_handler() noexcept;\t\n|[cpp11]|[<new>]
nothrow()Param: ()\t\nDesc:	Nothrow constant (constant)\t\nProto:\t\n|[cpp98 cpp11]|[<new>]
nothrow_t()Param: ()\t\nDesc: Nothrow type (type)\t\nProto: struct nothrow_t {};\t\n|[cpp98 cpp11]|[<new>]
operatordelete(void* ptr)Param: (A pointer to the memory block to be released, type-casted to a )\t\nDesc: Deallocate storage space (function)\t\nProto: void operator delete (void* ptr) throw();\t\n|[cpp98 cpp11]|[<new>]
operatordelete[](void* ptr)Param: (A pointer to the memory block to be released, type-casted to a )\t\nDesc: Deallocate storage space of array (function)\t\nProto: void operator delete[] (void* ptr) throw();\t\n|[cpp98 cpp11]|[<new>]
operatornew(std::size_t size) throw (std::bad_alloc)Param: (Size in bytes of the requested memory block.)\t\nDesc: Allocate storage space (function)\t\nProto: void* operator new (std::size_t size) throw (std::bad_alloc);\t\n|[cpp98 cpp11]|[<new>]
operatornew[](std::size_t size) throw (std::bad_alloc)Param: (Size in bytes of the requested memory block.)\t\nDesc: Allocate storage space for array (function)\t\nProto: void* operator new[] (std::size_t size) throw (std::bad_alloc);\t\n|[cpp98 cpp11]|[<new>]
set_new_handler(new_handler new_p)Param: (Function that takes no arguments and returns no value ()\t\nDesc: Set new handler function (function)\t\nProto: new_handler set_new_handler (new_handler new_p) throw();\t\n|[cpp98 cpp11]|[<new>]

#[<numeric>]	
accumulate(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Accumulate values in range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<numeric>]
adjacent_difference(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Compute adjacent difference of range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<numeric>]
inner_product(first1, last1)Param: (Input iterators to the initial and final positions in the first sequence.)\t\nDesc: Compute cumulative inner product of range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<numeric>]
iota(ForwardIterator first, ForwardIterator last, T val)Param: (Forward iterators to the initial and final positions of the sequence to be written.)\t\nDesc: Store increasing sequence (function template)\t\nProto: template <class ForwardIterator, class T>\t\nvoid iota (ForwardIterator first, ForwardIterator last, T val);\t\n|[cpp11]|[<numeric>]
partial_sum(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Compute partial sums of range (function template)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<numeric>]

#[<ostream>]	
basic_ostream(charT)Param: (Character type.)\t\nDesc: Output stream (class)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ostream;\t\n|[cpp98 cpp11 ]|[<ostream>]
basic_ostream(charT)Param: (Character type.)\t\nDesc: Output stream (class)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ostream;\t\n|[cpp98 cpp11 ]|[<ostream>]
endl(ostream& os)Param: (Output stream object affected.)\t\nDesc: Insert newline and flush (function)\t\nProto: for ostream\t\nostream& endl (ostream& os);basic template\t\ntemplate <class charT, class traits>\t\nbasic_ostream<charT,traits>& endl (basic_ostream<charT,traits>& os);\t\n|[arm cpp98 cpp11]|[<ostream>]
ends(ostream& os)Param: (Output stream object where character is inserted.)\t\nDesc: Insert null character (function)\t\nProto: for ostream\t\nostream& ends (ostream& os);basic template\t\ntemplate <class charT, class traits>\t\nbasic_ostream<charT,traits>& ends (basic_ostream<charT,traits>& os);\t\n|[arm cpp98 cpp11]|[<ostream>]
wostream()Param: ()\t\nDesc: Output stream (wide) (class)\t\nProto: typedef basic_ostream<wchar_t> wostream;\t\n|[arm cpp98 cpp11]|[<ostream>]

#[<queue>]
priority_queue(T)Param: (Type of the elements.)\t\nDesc: Priority queue (class template)\t\nProto: template <class T, class Container = vector<T>, class Compare = less<typename Container::value_type> > class priority_queue;\t\n|[cpp98 cpp11 ]|[<queue>]

[<random>]	
bernoulli_distribution()Param: ()\t\nDesc: Bernoulli distribution (class)\t\nProto: class bernoulli_distribution;\t\n|[cpp11 ]|[<random>]
binomial_distribution(IntType)Param: (An integer type.)\t\nDesc: Binomial distribution (class template)\t\nProto: template <class IntType = int> class binomial_distribution;\t\n|[cpp11 ]|[<random>]
cauchy_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Cauchy distribution (class template)\t\nProto: template <class RealType = double> class cauchy_distribution;\t\n|[cpp11 ]|[<random>]
chi_squared_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Chi-squared distribution (class template)\t\nProto: template <class RealType = double> class chi_squared_distribution;\t\n|[cpp11 ]|[<random>]
default_random_engine()Param: ()\t\nDesc: Default random engine (class)\t\nProto: no-proto\t\n|[cpp11]|[<random>]
discard_block_engine(Engine)Param: (A random number engine type.)\t\nDesc: Discard-block random number engine adaptor (class template)\t\nProto: template <class Engine, size_t p, size_t r>\t\nclass discard_block_engine;\t\n|[cpp11 ]|[<random>]
discrete_distribution(IntType)Param: (An integer type.)\t\nDesc: Discrete distribution (class template)\t\nProto: template <class IntType = int> class discrete_distribution;\t\n|[cpp11 ]|[<random>]
exponential_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Exponential distribution (class template)\t\nProto: template <class RealType = double> class exponential_distribution;\t\n|[cpp11 ]|[<random>]
extreme_value_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Extreme Value distribution (class template)\t\nProto: template <class RealType = double> class extreme_value_distribution;\t\n|[cpp11 ]|[<random>]
fisher_f_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Fisher F-distribution (class template)\t\nProto: template <class RealType = double> class fisher_f_distribution;\t\n|[cpp11 ]|[<random>]
gamma_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Gamma distribution (class template)\t\nProto: template <class RealType = double> class gamma_distribution;\t\n|[cpp11 ]|[<random>]
generate_canonical(URNG& g)Param: (A floating-point type.)\t\nDesc: Generate canonical numbers (function template)\t\nProto: template <class RealType, size_t bits, class URNG>\t\nRealType generate_canonical (URNG& g);\t\n|[cpp11]|[<random>]
geometric_distribution(IntType)Param: (An integer type.)\t\nDesc: Geometric distribution (class template)\t\nProto: template <class IntType = int> class geometric_distribution;\t\n|[cpp11 ]|[<random>]
independent_bits_engine(Engine)Param: (A random number engine type.)\t\nDesc: Independent-bits random number engine adaptor (class template)\t\nProto: template <class Engine, size_t w, class UIntType>\t\nclass independent_bits_engine;\t\n|[cpp11 ]|[<random>]
knuth_b()Param: ()\t\nDesc: Knuth-B generator (class)\t\nProto: typedef shuffle_order_engine <minstd_rand0,256> knuth_b;\t\n|[cpp11]|[<random>]
linear_congruential_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Linear congruential random number engine (class template)\t\nProto: template <class UIntType, UIntType a, UIntType c, UIntType m>\t\nclass linear_congruential_engine;\t\n|[cpp11 ]|[<random>]
lognormal_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Lognormal distribution (class template)\t\nProto: template <class RealType = double> class lognormal_distribution;\t\n|[cpp11 ]|[<random>]
mersenne_twister_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Mersenne twister random number engine (class template)\t\nProto: template <class UIntType, size_t w, size_t n, size_t m, size_t r,UIntType a, size_t u, UIntType d, size_t s,UIntType b, size_t t,UIntType c, size_t l, UIntType f>\t\nclass mersenne_twister_engine;\t\n|[cpp11 ]|[<random>]
minstd_rand()Param: ()\t\nDesc: Minimal Standard minstd_rand generator (class)\t\nProto: typedef linear_congruential_engine<uint_fast32_t, 48271, 0, 2147483647> minstd_rand;\t\n|[cpp11]|[<random>]
minstd_rand0()Param: ()\t\nDesc: Minimal Standard minstd_rand0 generator (class)\t\nProto: typedef linear_congruential_engine<uint_fast32_t, 16807, 0, 2147483647> minstd_rand0;\t\n|[cpp11]|[<random>]
mt19937()Param: ()\t\nDesc: Mersenne Twister 19937 generator (class)\t\nProto: typedef mersenne_twister_engine<uint_fast32_t,\t\n32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253>\t\nmt19937;\t\n|[cpp11]|[<random>]
mt19937_64()Param: ()\t\nDesc: Mersene Twister 19937 generator (64 bit) (class)\t\nProto: typedef mersenne_twister_engine<uint_fast64_t,\t\n64,312,156,31,0xb5026f5aa96619e9,\t\n29,0x5555555555555555,\t\n17,0x71d67fffeda60000,\t\n37,0xfff7eee000000000,\t\n43,6364136223846793005> mt19937_64;\t\n|[cpp11]|[<random>]
negative_binomial_distribution(IntType)Param: (An integer type.)\t\nDesc: Negative binomial distribution (class template)\t\nProto: template <class IntType = int> class negative_binomial_distribution;\t\n|[cpp11 ]|[<random>]
piecewise_constant_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Piecewise constant distribution (class template)\t\nProto: template <class RealType = double> class piecewise_constant_distribution;\t\n|[cpp11 ]|[<random>]
piecewise_linear_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Piecewise linear distribution (class template)\t\nProto: template <class RealType = double> class piecewise_linear_distribution;\t\n|[cpp11 ]|[<random>]
poisson_distribution(IntType)Param: (An integer type.)\t\nDesc: Poisson distribution (class template)\t\nProto: template <class IntType = int> class poisson_distribution;\t\n|[cpp11 ]|[<random>]
random_device()Param: ()\t\nDesc: True random number generator (class)\t\nProto: class random_device;\t\n|[cpp11 ]|[<random>]
ranlux24()Param: ()\t\nDesc: Ranlux 24 generator (class)\t\nProto: typedef discard_block_engine <ranlux24_base, 223, 23> ranlux24;\t\n|[cpp11]|[<random>]
ranlux24_base()Param: ()\t\nDesc: Ranlux 24 base generator (class)\t\nProto: typedef subtract_with_carry_engine <uint_fast32_t, 24, 10, 24> ranlux24_base;\t\n|[cpp11]|[<random>]
ranlux48()Param: ()\t\nDesc: Ranlux 48 generator (class)\t\nProto: typedef discard_block_engine <ranlux48_base, 389, 11> ranlux48;\t\n|[cpp11]|[<random>]
ranlux48_base()Param: ()\t\nDesc: Ranlux 48 base generator (class)\t\nProto: typedef subtract_with_carry_engine <uint_fast64_t, 48, 5, 12> ranlux48_base;\t\n|[cpp11]|[<random>]
seed_seq()Param: ()\t\nDesc: Seed sequence (class)\t\nProto: class seed_seq;\t\n|[cpp11 ]|[<random>]
shuffle_order_engine(Engine)Param: (A random number engine type.)\t\nDesc: Shuffle-order random number engine adaptor (class template)\t\nProto: template <class Engine, size_t k> class shuffle_order_engine;\t\n|[cpp11 ]|[<random>]
student_t_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Student T-Distribution (class template)\t\nProto: template <class RealType = double> class student_t_distribution;\t\n|[cpp11 ]|[<random>]
subtract_with_carry_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Subtract-with-carry random number engine (class template)\t\nProto: template <class UIntType, size_t w, size_t s, size_t r>\t\nclass subtract_with_carry_engine;\t\n|[cpp11 ]|[<random>]
uniform_int_distribution(IntType)Param: (An integer type.)\t\nDesc: Uniform discrete distribution (class template)\t\nProto: template <class IntType = int> class uniform_int_distribution;\t\n|[cpp11 ]|[<random>]
uniform_real_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Uniform real distribution (class template)\t\nProto: template <class RealType = double> class uniform_real_distribution;\t\n|[cpp11 ]|[<random>]
weibull_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Weibull distribution (class template)\t\nProto: template <class RealType = double> class weibull_distribution;\t\n|[cpp11 ]|[<random>]

#[<ratio>]	
ratio_add(R1,R2)Param: (ratio types to be added.)\t\nDesc: Add two ratios (class template)\t\nProto: template <class R1, class R2> ratio_add;\t\n|[cpp11]|[<ratio>]
ratio_divide(R1,R2)Param: (ratio types to be divided.)\t\nDesc: Divide ratios (class template)\t\nProto: template <class R1, class R2> ratio_divide;\t\n|[cpp11]|[<ratio>]
ratio_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios (class template)\t\nProto: template <class R1, class R2> ratio_equal;\t\n|[cpp11]|[<ratio>]
ratio_greater(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for greater than inequality (class template)\t\nProto: template <class R1, class R2> ratio_greater;\t\n|[cpp11]|[<ratio>]
ratio_greater_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for equality or greater-than inequality (class template)\t\nProto: template <class R1, class R2> ratio_greater_equal;\t\n|[cpp11]|[<ratio>]
ratio_less(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for less-than inequality (class template)\t\nProto: template <class R1, class R2> ratio_less;\t\n|[cpp11]|[<ratio>]
ratio_less_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for equality or less-than inequality (class template)\t\nProto: template <class R1, class R2> ratio_less_equal;\t\n|[cpp11]|[<ratio>]
ratio_multiply(R1,R2)Param: (ratio types to be multiplied.)\t\nDesc: Multiply two ratios (class template)\t\nProto: template <class R1, class R2> ratio_multiply;\t\n|[cpp11]|[<ratio>]
ratio_not_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for inequality (class template)\t\nProto: template <class R1, class R2> ratio_not_equal;\t\n|[cpp11]|[<ratio>]
ratio_subtract(R1,R2)Param: (ratio types to be subtracted.)\t\nDesc: Subtract ratios (class template)\t\nProto: template <class R1, class R2> ratio_subtract;\t\n|[cpp11]|[<ratio>]

#[<regex>]	
basic_regex(charT)Param: (The character type.)\t\nDesc: Regular expression (class template)\t\nProto: template <class charT, class traits = regex_traits<charT> > class basic_regex;\t\n|[cpp11 ]|[<regex>]
basic_regex(charT)Param: (The character type.)\t\nDesc: Regular expression (class template)\t\nProto: template <class charT, class traits = regex_traits<charT> > class basic_regex;\t\n|[cpp11 ]|[<regex>]
cmatch()Param: ()\t\nDesc: match_results for string literals (class)\t\nProto: typedef match_results<const char*> cmatch;\t\n|[cpp11]|[<regex>]
csub_match()Param: ()\t\nDesc: sub_match for string literals (class)\t\nProto: typedef sub_match<const char*> csub_match;\t\n|[cpp11]|[<regex>]
match_results(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Match results (class template)\t\nProto: template < class BidirectionalIterator, class Alloc = allocator< sub_match<BidirectionalIterator> > > class match_results;\t\n|[cpp11 ]|[<regex>]
regex_constants()Param: ()\t\nDesc: regex constants (namespace)\t\nProto: no-proto\t\n|[cpp11]|[<regex>]
regex_error()Param: ()\t\nDesc: Regex exception (class)\t\nProto: class regex_error : public runtime_error { /* ... */ };\t\n|[cpp11 ]|[<regex>]
regex_iterator(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Regex iterator (class template)\t\nProto: template <class BidirectionalIterator,class charT=typename iterator_traits<BidirectionalIterator>::value_type,class traits=regex_traits<charT> > class regex_iterator;\t\n|[cpp11 ]|[<regex>]
regex_match(s)Param: (A string with the target sequence (the subject) against which the regex expression is matched.)\t\nDesc: Match sequence (function template)\t\nProto: template <class charT, class traits> bool regex_match (const charT* s, const basic_regex<charT,traits>& rgx, regex_constants::match_flag_type flags = regex_constants::match_default);\t\n|[cpp11]|[<regex>]
regex_replace(s)Param: (A string with the target sequence (the subject).)\t\nDesc: Replace matched sequence (function template)\t\nProto: long-proto\t\n|[cpp11]|[<regex>]
regex_search(s)Param: (A string with the target sequence (the subject) to be searched for a match of the regex expression.)\t\nDesc: Search sequence (function template)\t\nProto: template <class charT, class traits> bool regex_search (const charT* s, const basic_regex<charT,traits>& rgx, regex_constants::match_flag_type flags = regex_constants::match_default);\t\n|[cpp11]|[<regex>]
regex_token_iterator(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Regex token iterator (class template)\t\nProto: template <class BidirectionalIterator,class charT=typename iterator_traits<BidirectionalIterator>::value_type,class traits=regex_traits<charT> > class regex_token_iterator;\t\n|[cpp11 ]|[<regex>]
regex_traits(charT)Param: (The character type.)\t\nDesc: Regex traits (class template)\t\nProto: template <class charT> class regex_traits;\t\n|[cpp11 ]|[<regex>]
ssub_match()Param: ()\t\nDesc: sub_match for strings (class)\t\nProto: typedef sub_match<string::const_iterator> ssub_match;\t\n|[cpp11]|[<regex>]
sub_match(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on a sequence of characters.)\t\nDesc: Sub-expression match (class template)\t\nProto: template <class BidirectionalIterator>\t\nclass sub_match : public pair <BidirectionalIterator, BidirectionalIterator>;\t\n|[cpp11 ]|[<regex>]
wcmatch()Param: ()\t\nDesc: match_results for wide string literals (class)\t\nProto: typedef match_results<const wchar_t*> wcmatch;\t\n|[cpp11]|[<regex>]
wcsub_match()Param: ()\t\nDesc: sub_match for wide string literals (class)\t\nProto: typedef sub_match<const wchar_t*> csub_match;\t\n|[cpp11]|[<regex>]
wregex()Param: ()\t\nDesc: Regex for wchar_t (class)\t\nProto: typedef basic_regex<wchar_t> wregex;\t\n|[cpp11]|[<regex>]
wsmatch()Param: ()\t\nDesc: match_results for wide string objects (class)\t\nProto: typedef match_results<wstring::const_iterator> smatch;\t\n|[cpp11]|[<regex>]
wssub_match()Param: ()\t\nDesc: sub_match for wide strings (class)\t\nProto: typedef sub_match<wstring::const_iterator> ssub_match;\t\n|[cpp11]|[<regex>]

#[<set>]
multiset(T)Param: (Type of the elements.)\t\nDesc: Multiple-key set (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<set>]

#[<sstream>]	
basic_istringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: Input string stream (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<sstream>]
basic_ostringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: Output string stream (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<sstream>]
basic_stringbuf(charT)Param: (Character type used by both the stream buffer and the basic_string objects it accepts or generates.)\t\nDesc: String stream buffer (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<sstream>]
basic_stringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: String stream (class template)\t\nProto: long-proto\t\n|[cpp98 cpp11 ]|[<sstream>]
wistringstream()Param: ()\t\nDesc: Input string stream (wide) (class)\t\nProto: typedef basic_istringstream<wchar_t> wistringstream;\t\n|[cpp98 cpp11]|[<sstream>]
wostringstream()Param: ()\t\nDesc: Output string stream (wide) (class)\t\nProto: typedef basic_ostringstream<wchar_t> wostringstream;\t\n|[cpp98 cpp11]|[<sstream>]
wstringbuf()Param: ()\t\nDesc: String stream buffer (wide) (class)\t\nProto: typedef basic_stringbuf<wchar_t> wstringbuf;\t\n|[cpp98 cpp11]|[<sstream>]
wstringstream()Param: ()\t\nDesc: Input/output string stream (wide) (class)\t\nProto: typedef basic_stringstream<wchar_t> wstringstream;\t\n|[cpp98 cpp11]|[<sstream>]

#[<stack>]
stack(T)Param: (Type of the elements.)\t\nDesc: LIFO stack (class template)\t\nProto: template <class T, class Container = deque<T> > class stack;\t\n|[cpp98 cpp11 ]|[<stack>]

#[<cstdalign>]
alignas(type-id)Desc:Specifies the alignment requirement of a type or an object.[cpp11][cstdalign]
alignof(type-id)Desc:Queries alignment requirements of a type.[cpp11][cstalign]

#[<stdexcept>]
domain_error()Param: ()\t\nDesc: Domain error exception (class)\t\nProto: class domain_error;\t\n|[cpp98 cpp11]|[<stdexcept>]
invalid_argument()Param: ()\t\nDesc: Invalid argument exception (class)\t\nProto: class invalid_argument;\t\n|[cpp98 cpp11]|[<stdexcept>]
length_error()Param: ()\t\nDesc: Length error exception (class)\t\nProto: class length_error;\t\n|[cpp98 cpp11]|[<stdexcept>]
logic_error()Param: ()\t\nDesc: Logic error exception (class)\t\nProto: class logic_error;\t\n|[cpp98 cpp11]|[<stdexcept>]
out_of_range()Param: ()\t\nDesc: Out-of-range exception (class)\t\nProto: class out_of_range;\t\n|[cpp98 cpp11]|[<stdexcept>]
overflow_error()Param: ()\t\nDesc: Overflow error exception (class)\t\nProto: class overflow_error;\t\n|[cpp98 cpp11]|[<stdexcept>]
range_error()Param: ()\t\nDesc: Range error exception (class)\t\nProto: class range_error;\t\n|[cpp98 cpp11]|[<stdexcept>]
runtime_error()Param: ()\t\nDesc: Runtime error exception (class)\t\nProto: class runtime_error;\t\n|[cpp98 cpp11]|[<stdexcept>]
underflow_error()Param: ()\t\nDesc: Underflow error exception (class)\t\nProto: class underflow_error;\t\n|[cpp98 cpp11]|[<stdexcept>]

#[<streambuf>]	
basic_streambuf(charT)Param: (Character type.)\t\nDesc: Base buffer class for streams (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_streambuf;\t\n|[cpp98 cpp11 ]|[<streambuf>]
basic_streambuf(charT)Param: (Character type.)\t\nDesc: Base buffer class for streams (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_streambuf;\t\n|[cpp98 cpp11 ]|[<streambuf>]
wstreambuf()Param: ()\t\nDesc: Base buffer class for streams (wide) (class)\t\nProto: typedef basic_streambuf<wchar_t> wstreambuf;\t\n|[cpp98 cpp11]|[<streambuf>]

#[<string>]	
char_traits(charT)Param: (Character type.)\t\nDesc: Character traits (class template)\t\nProto: template <class charT> struct char_traits;template <> struct char_traits<char>;template <> struct char_traits<wchar_t>;\t\n|[cpp98 cpp11 ]|[<string>]
char_traits(charT)Param: (Character type.)\t\nDesc: Character traits (class template)\t\nProto: template <class charT> struct char_traits;template <> struct char_traits<char>;template <> struct char_traits<wchar_t>;\t\n|[cpp98 cpp11 ]|[<string>]
stoi(const string& str, size_t* idx = 0, int base = 10)Param: (String object with the representation of an integral number.)\t\nDesc: Convert string to integer (function template)\t\nProto: int stoi (const string& str, size_t* idx = 0, int base = 10);\t\nProto: int stoi (const wstring& str, size_t* idx = 0, int base = 10);\t\n|[cpp11]|[<string>]
to_string(val)Param: (Numerical value.)\t\nDesc: Convert numerical value to string (function)\t\nProto: long-proto\t\n|[cpp11]|[<string>]
to_wstring(val)Param: (Numerical value.)\t\nDesc: Convert numerical value to wide string (function)\t\nProto: long-proto\t\n|[cpp11]|[<string>]
u16string()Param: ()\t\nDesc: String of 16-bit characters (class)\t\nProto: typedef basic_string<char16_t> u16string;\t\n|[cpp11]|[<string>]
u32string()Param: ()\t\nDesc: String of 32-bit characters (class)\t\nProto: typedef basic_string<char32_t> u32string;\t\n|[cpp11]|[<string>]

#[<system_error>]
error_category()Param: ()\t\nDesc: Error category (abstract class)\t\nProto: class error_category;\t\n|[cpp11 ]|[<system_error>]
error_code()Param: ()\t\nDesc: Error code (class)\t\nProto: class error_code;\t\n|[cpp11 ]|[<system_error>]
error_condition()Param: ()\t\nDesc: Error condition (class)\t\nProto: class error_condition;\t\n|[cpp11 ]|[<system_error>]
generic_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return generic category (function)\t\nProto: const error_category& generic_category() noexcept;\t\n|[cpp11]|[<system_error>]
is_error_code_enum(T)Param: (A type.)\t\nDesc: error_code enum flag (class)\t\nProto: template <class T>\t\nstruct is_error_code_enum : public false_type {};\t\n|[cpp11]|[<system_error>]
is_error_condition_enum(T)Param: (A type.)\t\nDesc: error_condition enum flag (class)\t\nProto: template <class T>\t\nstruct is_error_condition_enum : public false_type {};template<>\t\nstruct is_error_condition_enum<errc> : true_type {};\t\n|[cpp11]|[<system_error>]
make_error_code(errc e)Param: (An enum value of type errc (see errc).)\t\nDesc: Make error code (function)\t\nProto: error_code make_error_code (errc e) noexcept;\t\n|[cpp11]|[<system_error>]
make_error_condition(errc e)Param: (An enum value of type errc (see errc).)\t\nDesc: Make error condition (function)\t\nProto: error_condition make_error_condition (errc e) noexcept;\t\n|[cpp11]|[<system_error>]
system_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return system category (function)\t\nProto: const error_category& system_category() noexcept;\t\n|[cpp11]|[<system_error>]
system_error()Param: ()\t\nDesc: System error exception (class)\t\nProto: class system_error : public runtime_error;\t\n|[cpp11 ]|[<system_error>]

#[<thread>]
this_thread()Param: ()\t\nDesc: This thread (namespace)\t\nProto: no-proto\t\n|[cpp11 ]|[<thread>]

#[<tuple>]
forward_as_tuple(Types&&... args)Param: (List of elements to be forwarded as a tuple object of references.)\t\nDesc: Forward as tuple (function template)\t\nProto: template<class... Types> tuple<Types&&...> forward_as_tuple (Types&&... args) noexcept;\t\n|[cpp11]|[<tuple>]
ignore()Param: ()\t\nDesc: Ignore assignment (object)\t\nProto: const ignore;\t\n|[cpp11]|[<tuple>]
make_tuple(Types&&... args)Param: (List of elements that the constructed tuple shall contain.)\t\nDesc: Construct tuple (function template)\t\nProto: template<class... Types>\t\ntuple<VTypes...> make_tuple (Types&&... args);\t\n|[cpp11]|[<tuple>]
tie(Types&... args)Param: (List of objects (lvalues) to be tied as elements of a tuple.)\t\nDesc: Tie arguments to tuple elements (function template)\t\nProto: template<class... Types> tuple<Types&...> tie (Types&... args) noexcept;\t\n|[cpp11]|[<tuple>]
tuple(Types...)Param: (A list of types used for the elements, in the same order as they are going to be ordered in the tuple.)\t\nDesc: Tuple (class template)\t\nProto: template <class... Types> class tuple;\t\n|[cpp11 ]|[<tuple>]
tuple_cat(Tuples&&... tpls)Param: (Comma-separated list of tuple objects.)\t\nDesc: Concatenate tuples (function template)\t\nProto: template <class... Tuples>\t\ntuple<CTypes...> tuple_cat (Tuples&&... tpls);\t\n|[cpp11]|[<tuple>]
tuple_element(I)Param: (Order number of the element within the tuple (zero-based).)\t\nDesc: Tuple element type (class template)\t\nProto: long-proto\t\n|[cpp11]|[<tuple>]
tuple_size(T)Param: (Type for which the tuple size is obtained.)\t\nDesc: Tuple size traits (class template)\t\nProto: long-proto\t\n|[cpp11]|[<tuple>]

#[<type_traits>]
add_const(T)Param: (A type.)\t\nDesc: Add const qualification (class template)\t\nProto: template <class T> struct add_const;\t\n|[cpp11]|[<type_traits>]
add_cv(T)Param: (A type.)\t\nDesc: Add const volatile qualification (class template)\t\nProto: template <class T> struct add_cv;\t\n|[cpp11]|[<type_traits>]
add_lvalue_reference(T)Param: (A type.)\t\nDesc: Add lvalue reference (class template)\t\nProto: template <class T> struct add_lvalue_reference;\t\n|[cpp11]|[<type_traits>]
add_pointer(T)Param: (A type.)\t\nDesc: Add pointer (class template)\t\nProto: template <class T> struct add_pointer;\t\n|[cpp11]|[<type_traits>]
add_rvalue_reference(T)Param: (A type.)\t\nDesc: Add rvalue reference (class template)\t\nProto: template <class T> struct add_rvalue_reference;\t\n|[cpp11]|[<type_traits>]
add_volatile(T)Param: (A type.)\t\nDesc: Add volatile qualification (class template)\t\nProto: template <class T> struct add_volatile;\t\n|[cpp11]|[<type_traits>]
aligned_storage(Len)Param: (The size of the storage object, in bytes.)\t\nDesc: Aligned storage (class template)\t\nProto: template <size_t Len, size_t Align = /* default alignment */>\t\nstruct aligned_storage;\t\n|[cpp11]|[<type_traits>]
aligned_union(Len)Param: (The minimum size of the storage object, in bytes.)\t\nDesc: Aligned union (class template)\t\nProto: template <size_t Len, class... Types> struct aligned_union;\t\n|[cpp11]|[<type_traits>]
alignment_of(T)Param: (A complete object type, or an array thereof, or a reference to a complete object type.)\t\nDesc: Alignment of (class template)\t\nProto: template <class T> struct alignment_of;\t\n|[cpp11]|[<type_traits>]
conditional(Cond)Param: (A compile-time constant of type bool.)\t\nDesc: Conditional type (class template)\t\nProto: template <bool Cond, class T, class F> struct conditional;\t\n|[cpp11]|[<type_traits>]
decay(T)Param: (A type.)\t\nDesc: Decay type (class template)\t\nProto: template <class T> struct decay;\t\n|[cpp11]|[<type_traits>]
enable_if(Cond)Param: (A compile-time constant of type bool.)\t\nDesc: Enable type if condition is met (class template)\t\nProto: template <bool Cond, class T = void> struct enable_if;\t\n|[cpp11]|[<type_traits>]
extent(T)Param: (A type.)\t\nDesc: Array dimension extent (class template)\t\nProto: template <class T, unsigned I = 0> struct extent;\t\n|[cpp11]|[<type_traits>]
false_type()Param: ()\t\nDesc: False type (class)\t\nProto: typedef integral_constant<bool,false> false_type;\t\n|[cpp11]|[<type_traits>]
has_virtual_destructor(T)Param: (A complete type, or )\t\nDesc: Has virtual destructor (class template)\t\nProto: template <class T> struct has_virtual_destructor;\t\n|[cpp11]|[<type_traits>]
integral_constant(T)Param: (Type of the integral constant.)\t\nDesc: Integral constant (class template)\t\nProto: template <class T, T v>struct integral_constant;\t\n|[cpp11 ]|[<type_traits>]
is_abstract(T)Param: (A complete type, or )\t\nDesc: Is abstract class (class template)\t\nProto: template <class T> struct is_abstract;\t\n|[cpp11]|[<type_traits>]
is_arithmetic(T)Param: (A type.)\t\nDesc: Is arithmetic type (class template)\t\nProto: template <class T> struct is_arithmetic;\t\n|[cpp11]|[<type_traits>]
is_array(T)Param: (A type.)\t\nDesc: Is array (class template)\t\nProto: template <class T> struct is_array;\t\n|[cpp11]|[<type_traits>]
is_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is assignable (class template)\t\nProto: template <class T, class U> struct is_assignable;\t\n|[cpp11]|[<type_traits>]
is_base_of(Base)Param: (A type.)\t\nDesc: Is base class of (class template)\t\nProto: template <class Base, class Derived> struct is_base_of;\t\n|[cpp11]|[<type_traits>]
is_class(T)Param: (A type.)\t\nDesc: Is non-union class (class template)\t\nProto: template <class T> struct is_class;\t\n|[cpp11]|[<type_traits>]
is_compound(T)Param: (A type.)\t\nDesc: Is compound type (class template)\t\nProto: template <class T> struct is_compound;\t\n|[cpp11]|[<type_traits>]
is_const(T)Param: (A type.)\t\nDesc: Is const-qualified (class template)\t\nProto: template <class T> struct is_const;\t\n|[cpp11]|[<type_traits>]
is_constructible(T)Param: (A complete type, or )\t\nDesc: Is constructible (class template)\t\nProto: template <class T, class... Args> struct is_constructible;\t\n|[cpp11]|[<type_traits>]
is_convertible(From, To)Param: (Complete types, or )\t\nDesc: Is convertible (class template)\t\nProto: template <class From, class To> struct is_convertible;\t\n|[cpp11]|[<type_traits>]
is_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is copy assignable (class template)\t\nProto: template <class T> struct is_copy_assignable;\t\n|[cpp11]|[<type_traits>]
is_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is copy constructible (class template)\t\nProto: template <class T> struct is_copy_constructible;\t\n|[cpp11]|[<type_traits>]
is_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is default constructible (class template)\t\nProto: template <class T> struct is_default_constructible;\t\n|[cpp11]|[<type_traits>]
is_destructible(T)Param: (A complete type, or )\t\nDesc: Is destructible (class template)\t\nProto: template <class T> struct is_destructible;\t\n|[cpp11]|[<type_traits>]
is_empty(T)Param: (\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or )\t\nDesc: Is empty class (class template)\t\nProto: template <class T> struct is_empty;\t\n|[cpp11]|[<type_traits>]
is_enum(T)Param: (A type.)\t\nDesc: Is enum (class template)\t\nProto: template <class T> struct is_enum;\t\n|[cpp11]|[<type_traits>]
is_floating_point(T)Param: (A type.)\t\nDesc: Is floating point (class template)\t\nProto: template <class T> struct is_floating_point;\t\n|[cpp11]|[<type_traits>]
is_function(T)Param: (A type.)\t\nDesc: Is function (class template)\t\nProto: template <class T> struct is_function;\t\n|[cpp11]|[<type_traits>]
is_fundamental(T)Param: (A type.)\t\nDesc: Is fundamental type (class template)\t\nProto: template <class T> struct is_fundamental;\t\n|[cpp11]|[<type_traits>]
is_integral(T)Param: (A type.)\t\nDesc: Is integral (class template)\t\nProto: template <class T> struct is_integral;\t\n|[cpp11]|[<type_traits>]
is_literal_type(T)Param: (A complete type, or )\t\nDesc: Is literal type (class template)\t\nProto: template <class T> struct is_literal_type;\t\n|[cpp11]|[<type_traits>]
is_lvalue_reference(T)Param: (A type.)\t\nDesc: Is lvalue reference (class template)\t\nProto: template <class T> struct is_lvalue_reference;\t\n|[cpp11]|[<type_traits>]
is_member_function_pointer(T)Param: (A type.)\t\nDesc: Is member function pointer (class template)\t\nProto: template <class T> struct is_member_function_pointer;\t\n|[cpp11]|[<type_traits>]
is_member_object_pointer(T)Param: (A type.)\t\nDesc: Is member object pointer (class template)\t\nProto: template <class T> struct is_member_object_pointer;\t\n|[cpp11]|[<type_traits>]
is_member_pointer(T)Param: (A type.)\t\nDesc: Is member pointer type (class template)\t\nProto: template <class T> struct is_member_pointer;\t\n|[cpp11]|[<type_traits>]
is_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is move assignable (class template)\t\nProto: template <class T> struct is_move_assignable;\t\n|[cpp11]|[<type_traits>]
is_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is move constructible (class template)\t\nProto: template <class T> struct is_move_constructible;\t\n|[cpp11]|[<type_traits>]
is_nothrow_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is assignable throwing no exceptions (class template)\t\nProto: template <class T, class U> struct is_nothrow_assignable;\t\n|[cpp11]|[<type_traits>]
is_nothrow_constructible(T)Param: (A complete type, or )\t\nDesc: Is constructible throwing no exceptions (class template)\t\nProto: template <class T, class... Args> struct is_nothrow_constructible;\t\n|[cpp11]|[<type_traits>]
is_nothrow_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is copy assignable throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_copy_assignable;\t\n|[cpp11]|[<type_traits>]
is_nothrow_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is copy constructible throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_copy_constructible;\t\n|[cpp11]|[<type_traits>]
is_nothrow_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is default constructible throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_default_constructible;\t\n|[cpp11]|[<type_traits>]
is_nothrow_destructible(T)Param: (A complete type, or )\t\nDesc: Is nothrow destructible (class template)\t\nProto: template <class T> struct is_nothrow_destructible;\t\n|[cpp11]|[<type_traits>]
is_nothrow_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is move assignable throwing no exception (class template)\t\nProto: template <class T> struct is_nothrow_move_assignable;\t\n|[cpp11]|[<type_traits>]
is_nothrow_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is move constructible throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_move_constructible;\t\n|[cpp11]|[<type_traits>]
is_null_pointer(T)Param: (A type.)\t\nDesc: no-Description (other)\t\nProto: template <class T> struct is_null_pointer;\t\n|[cpp14]|[<type_traits>]
is_object(T)Param: (A type.)\t\nDesc: Is object type (class template)\t\nProto: template <class T> struct is_object;\t\n|[cpp11]|[<type_traits>]
is_pod(T)Param: (A complete type, or )\t\nDesc: Is POD type (class template)\t\nProto: template <class T> struct is_pod;\t\n|[cpp11]|[<type_traits>]
is_pointer(T)Param: (A type.)\t\nDesc: Is pointer (class template)\t\nProto: template <class T> struct is_pointer;\t\n|[cpp11]|[<type_traits>]
is_polymorphic(T)Param: (A complete type, or )\t\nDesc: Is polymorphic (class template)\t\nProto: template <class T> struct is_polymorphic;\t\n|[cpp11 cpp14]|[<type_traits>]
is_reference(T)Param: (A type.)\t\nDesc: Is reference type (class template)\t\nProto: template <class T> struct is_reference;\t\n|[cpp11]|[<type_traits>]
is_rvalue_reference(T)Param: (A type.)\t\nDesc: Is rvalue reference (class template)\t\nProto: template <class T> struct is_rvalue_reference;\t\n|[cpp11]|[<type_traits>]
is_same(T, U)Param: (Types.)\t\nDesc: Is same type (class template)\t\nProto: template <class T, class U> struct is_same;\t\n|[cpp11]|[<type_traits>]
is_scalar(T)Param: (A type.)\t\nDesc: Is scalar type (class template)\t\nProto: template <class T> struct is_scalar;\t\n|[cpp11]|[<type_traits>]
is_signed(T)Param: (A type.)\t\nDesc: Is signed type (class template)\t\nProto: template <class T> struct is_signed;\t\n|[cpp11]|[<type_traits>]
is_standard_layout(T)Param: (A complete type, or )\t\nDesc: Is standard-layout type (class template)\t\nProto: template <class T> struct is_standard_layout;\t\n|[cpp11]|[<type_traits>]
is_trivial(T)Param: (A complete type, or )\t\nDesc: Is trivial type (class template)\t\nProto: template <class T> struct is_trivial;\t\n|[cpp11]|[<type_traits>]
is_trivially_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is trivially assignable (class template)\t\nProto: template <class T, class U> struct is_trivially_assignable;\t\n|[cpp11]|[<type_traits>]
is_trivially_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially constructible (class template)\t\nProto: template <class T, class... Args> struct is_trivially_constructible;\t\n|[cpp11]|[<type_traits>]
is_trivially_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is trivially copy assignable (class template)\t\nProto: template <class T> struct is_trivially_copy_assignable;\t\n|[cpp11]|[<type_traits>]
is_trivially_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially copy constructible (class template)\t\nProto: template <class T> struct is_trivially_copy_constructible;\t\n|[cpp11]|[<type_traits>]
is_trivially_copyable(T)Param: (A complete type, or )\t\nDesc: Is trivially copyable (class template)\t\nProto: template <class T> struct is_trivially_copyable;\t\n|[cpp11]|[<type_traits>]
is_trivially_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially default constructible (class template)\t\nProto: template <class T> struct is_trivially_default_constructible;\t\n|[cpp11]|[<type_traits>]
is_trivially_destructible(T)Param: (A complete type, or )\t\nDesc: Is trivially destructible (class template)\t\nProto: template <class T> struct is_trivially_destructible;\t\n|[cpp11]|[<type_traits>]
is_trivially_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is trivially move assignable (class template)\t\nProto: template <class T> struct is_trivially_move_assignable;\t\n|[cpp11]|[<type_traits>]
is_trivially_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially move constructible (class template)\t\nProto: template <class T> struct is_trivially_move_constructible;\t\n|[cpp11]|[<type_traits>]
is_union(T)Param: (A type.)\t\nDesc: Is union (class template)\t\nProto: template <class T> struct is_union;\t\n|[cpp11]|[<type_traits>]
is_unsigned(T)Param: (A type.)\t\nDesc: Is unsigned type (class template)\t\nProto: template <class T> struct is_unsigned;\t\n|[cpp11]|[<type_traits>]
is_void(T)Param: (A type.)\t\nDesc: Is void (class template)\t\nProto: template <class T> struct is_void;\t\n|[cpp11]|[<type_traits>]
is_volatile(T)Param: (A type.)\t\nDesc: Is volatile-qualified (class template)\t\nProto: template <class T> struct is_volatile;\t\n|[cpp11]|[<type_traits>]
make_signed(T)Param: (An integer type (except bool), or an enumeration type.)\t\nDesc: Make signed (class template)\t\nProto: template <class T> struct make_signed;\t\n|[cpp11]|[<type_traits>]
make_unsigned(T)Param: (An integer type (except bool), or an enumeration type.)\t\nDesc: Make unsigned (class template)\t\nProto: template <class T> struct make_unsigned;\t\n|[cpp11]|[<type_traits>]
rank(T)Param: (A type.)\t\nDesc: Array rank (class template)\t\nProto: template <class T> struct rank;\t\n|[cpp11]|[<type_traits>]
remove_all_extents(T)Param: (A type.)\t\nDesc: Remove all array extents (class template)\t\nProto: template <class T> struct remove_all_extents;\t\n|[cpp11]|[<type_traits>]
remove_const(T)Param: (A type.)\t\nDesc: Remove const qualification (class template)\t\nProto: template <class T> struct remove_const;\t\n|[cpp11]|[<type_traits>]
remove_cv(T)Param: (A type.)\t\nDesc: Remove cv qualification (class template)\t\nProto: template <class T> struct remove_cv;\t\n|[cpp11]|[<type_traits>]
remove_extent(T)Param: (A type.)\t\nDesc: Remove array extent (class template)\t\nProto: template <class T> struct remove_extent;\t\n|[cpp11]|[<type_traits>]
remove_pointer(T)Param: (A type.)\t\nDesc: Remove pointer (class template)\t\nProto: template <class T> struct remove_pointer;\t\n|[cpp11]|[<type_traits>]
remove_reference(T)Param: (A type.)\t\nDesc: Remove reference (class template)\t\nProto: template <class T> struct remove_reference;\t\n|[cpp11]|[<type_traits>]
remove_volatile(T)Param: (A type.)\t\nDesc: Remove volatile qualification (class template)\t\nProto: template <class T> struct remove_volatile;\t\n|[cpp11]|[<type_traits>]
result_of(Fn)Param: (A callable type (i.)\t\nDesc: Result of call (class template)\t\nProto: template <class Fn, class... ArgTypes> struct result_of<Fn(ArgTypes...)>;\t\n|[cpp11]|[<type_traits>]
true_type()Param: ()\t\nDesc: True type (class)\t\nProto: typedef integral_constant<bool,true> true_type;\t\n|[cpp11]|[<type_traits>]
underlying_type(T)Param: (An enumeration type (enum).)\t\nDesc: Underlying type of enum (class template)\t\nProto: template <class T> struct underlying_type;\t\n|[cpp11]|[<type_traits>]

#[<typeindex>]	
type_index()Param: ()\t\nDesc: Type index (class)\t\nProto: class type_index;\t\n|[cpp11 ]|[<typeindex>]

#[<typeinfo>]	
bad_cast()Param: ()\t\nDesc: Exception thrown on failure to dynamic cast (class)\t\nProto: class bad_cast;\t\n|[cpp98 cpp11]|[<typeinfo>]
bad_typeid()Param: ()\t\nDesc: Exception thrown on typeid of null pointer (class)\t\nProto: class bad_typeid;\t\n|[cpp98 cpp11]|[<typeinfo>]
type_info()Param: ()\t\nDesc: Type information type (class)\t\nProto: class type_info;\t\n|[cpp98 cpp11 ]|[<typeinfo>]

#[<unordered_map>]	
unordered_map(Key)Param: (Type of the key values.)\t\nDesc: Unordered Map (class template)\t\nProto: long-proto\t\n|[cpp11 ]|[<unordered_map>]
unordered_multimap(Key)Param: (Type of the key values.)\t\nDesc: Unordered Multimap (class template)\t\nProto: long-proto\t\n|[cpp11 ]|[<unordered_map>]

#[<unordered_set>]
unordered_multiset(Key)Param: (Type of the elements.)\t\nDesc: Unordered Multiset (class template)\t\nProto: long-proto\t\n|[cpp11 ]|[<unordered_set>]
unordered_set(Key)Param: (Type of the elements.)\t\nDesc: Unordered Set (class template)\t\nProto: long-proto\t\n|[cpp11 ]|[<unordered_set>]

#[<utility>]
declval( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Declaration value (function template)\t\nProto: template <class T>\t\ntypename add_rvalue_reference<T>::type declval() noexcept;\t\n|[cpp11]|[<utility>]
make_pair(T1 x, T2 y)Param: (Values for the members first and second, respectively, of the pair object being constructed.)\t\nDesc: Construct pair object (function template)\t\nProto: template <class T1, class T2> pair<T1,T2> make_pair (T1 x, T2 y);\t\n|[cpp98 cpp11]|[<utility>]
move_if_noexcept(T& arg)Param: (An object.)\t\nDesc: Move if noexcept (function template)\t\nProto: !is_copy_constructible<T>::value,T&&, const T& >::type move_if_noexcept(T& arg) noexcept;\t\n|[cpp11]|[<utility>]
pair(T1)Param: (Type of member first, aliased as first_type.)\t\nDesc: Pair of values (class template)\t\nProto: template <class T1, class T2> struct pair;\t\n|[cpp98 cpp11 ]|[<utility>]
piecewise_construct_t()Param: ()\t\nDesc: Piecewise construct type (type)\t\nProto: struct piecewise_construct_t {};\t\n|[cpp11]|[<utility>]
rel_ops(T)Param: (For operator!=, the type shall be EqualityComparable.)\t\nDesc: Relational Operators (namespace)\t\nProto: long-proto\t\n|[cpp98 cpp11]|[<utility>]

#[<valarray>]
gslice()Param: ()\t\nDesc: Valarray generalized slice selector (class)\t\nProto: class gslice;\t\n|[cpp98 cpp11 ]|[<valarray>]
gslice_array()Param: ()\t\nDesc: Valarray gslice selection (class template)\t\nProto: template <class T> gslice_array;\t\n|[cpp98 cpp11]|[<valarray>]
indirect_array()Param: ()\t\nDesc: Valarray indirect selection (class template)\t\nProto: template <class T> indirect_array;\t\n|[cpp98 cpp11]|[<valarray>]
mask_array()Param: ()\t\nDesc: Valarray mask selection (class template)\t\nProto: template <class T> mask_array;\t\n|[cpp98 cpp11]|[<valarray>]
valarray(T)Param: (Type of the elements contained in the valarray.)\t\nDesc: Valarray class (class template)\t\nProto: template <class T> class valarray;\t\n|[cpp98 cpp11 ]|[<valarray>]

#[<vector>]	
vector(T)Param: (Type of the elements.)\t\nDesc: Vector (class template)\t\nProto: template < class T, class Alloc = allocator<T> > class vector;\t\n|[cpp98 cpp11 ]|[<vector>]

#[ClassTemplates]
bit_or(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise OR function object class (class template)\t\nProto: template <class T> struct bit_or;\t\n[class template]|[cpp11][]
logical_or(T)Param: (Type of the arguments passed to the functional call.)\t\nDesc: Logical OR function object class (class template)\t\nProto: template <class T> struct logical_or;\t\n|[cpp14]|[class template]

#Todo
######################

# Test: Class member calltips. Here <basic_string>
# add . to autocomplete/calltip word characters
.get_allocator()<basic_string> Desc:
.assign() <basic_string> Desc:
.at()<basic_string> Desc:
.front()<basic_string> Desc:
.back()<basic_string> Desc:
.data()<basic_string> Desc:
.c_str()<basic_string> Desc:
.begin()<basic_string> Desc:
.end()<basic_string> Desc:
.rbegin()<basic_string> Desc:
.rend()<basic_string> Desc:
.empty()<basic_string> Desc:
.size()<basic_string> Desc:
.length()<basic_string> Desc:
.max_size()<basic_string> Desc:
.reserve capacity()<basic_string> Desc:
.shrink_to_fit()<basic_string> Desc:
.clear()<basic_string> Desc:
.insert()<basic_string> Desc:
.erase()<basic_string> Desc:
.push_back()<basic_string> Desc:
.pop_back()<basic_string> Desc:
.append()<basic_string> Desc:
.compare()<basic_string> Desc:
.replace()<basic_string> Desc:
.substr()<basic_string> Desc:
.copy()<basic_string> Desc:
.resize()<basic_string> Desc:
.swap()<basic_string> Desc:
.find()<basic_string> Desc:
.rfind()<basic_string> Desc:
.find_first_of()<basic_string> Desc:
.find_first_not_of()<basic_string> Desc:
.find_last_of()<basic_string> Desc:
.find_last_not_of()<basic_string> Desc:
.npos()<basic_string> Desc:

# Test: Classes and Convenience Typedefs
# add : to autocomplete/calltip word characters
std::duration()TestTest Desc:
std::time_point
std::system_clock
std::high_resolution_clock
std::treat_as_floating_point
std::duration_values
std::common_type
std::basic_string
std::char_traits
std::string
std::wstring
std::u16string
std::u32string
