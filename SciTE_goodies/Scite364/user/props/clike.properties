# Define SciTE settings for C++, C, Ch, IDL, Flash (ActionScript 2) files.
# CleanUp Jun 2016, Marcedo@HabmalneFrage.de
# -> extrapolated c#, java and javascript handling for better maintainability.

file.patterns.cpp=*.c;*.cc;*.cpp;*.cxx;*.h;*.hh;*.hpp;*.hxx;*.ipp;*.m;*.mm
file.patterns.rc=*.rc;*.rc2;*.dlg;*.def
file.patterns.idl=*.idl;*.odl

# ---- C-Like Languages
# go (used on google)
file.patterns.go=*.go
# vala (used on gnome gtk+ )
file.patterns.vala=*.vala
# pike (used on Macintosh)
file.patterns.pike=*.pike
# Actionscript
file.patterns.flash=*.as;*.asc;*.jsfl
# pln, inc and t = SilkTest (4Test, automated function and regression testing) 
file.patterns.test=*.pln;*.inc;*.t
# sma files (SMAll script C-like)
file.patterns.sma=*.sma

file.patterns.c.like=$(file.patterns.go);$(file.patterns.vala);$(file.patterns.pike);$(file.patterns.flash);$(file.patterns.sma)

*source.patterns.cpp=$(file.patterns.cpp);
*source.patterns.resource=$(file.patterns.rc);

*filter.cpp=C/C++ ( c cpp cxx hpp h rc def idl )|$(file.patterns.cpp);$(file.patterns.rc);$(file.patterns.idl)|
*filter.clike=C-Based ( vala go pike swift flash )|$(file.patterns.c.like)|
*language.c=&C / C++|||

shbang.tcc=cpp
shbang.tinycc=cpp

lexer.$(file.patterns.cpp)=cpp
lexer.$(file.patterns.rc)=cpp
lexer.$(file.patterns.idl)=cpp
# moved c_sharp 
lexer.$(file.patterns.test)=cpp
# moved javascript
# moved java 
lexer.$(file.patterns.flash)=cpp
lexer.$(file.patterns.vala)=cpp
lexer.$(file.patterns.go)=cpp
lexer.$(file.patterns.pike)=cpp

keywordclass.cpp=alignas alignof and and_eq asm auto bitand bitor bool break \
case catch char class compl const const_cast constexpr continue \
default delete do double dynamic_cast else enum explicit export extern false float for \
friend goto if inline int long mutable namespace new not not_eq \
operator or or_eq private protected public \
register reinterpret_cast return short signed sizeof static static_cast struct switch \
template this throw true try typedef typeid typename union unsigned using \
virtual void volatile wchar_t while xor xor_eq std

# Macros & specials
keywordclass.cpp2=FENV_ACCESS FE_ALL_EXCEPT FE_DFL_ENV FE_DIVBYZERO FE_DOWNWARD FE_INEXACT FE_INVALID FE_OVERFLOW FE_TONEAREST FE_TOWARDZERO FE_UNDERFLOW FE_UPWARD NULL HUGE_VAL HUGE_VALF HUGE_VALL INFINITY NAN FILE BUFSIZ EOF FILENAME_MAX FOPEN_MAX L_tmpnam TMP_MAX EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX RAND_MAX CLOCKS_PER_SEC WCHAR_MAX WCHAR_MIN WEOF ATOMIC_FLAG_INIT ATOMIC_VAR_INIT 
# Copied from api file
keywordclass.cpp3=array atomic_flag atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_exchange atomic_exchange_explicit atomic_fetch_add atomic_fetch_add_explicit atomic_fetch_and atomic_fetch_and_explicit atomic_fetch_or atomic_fetch_or_explicit atomic_fetch_sub atomic_fetch_sub_explicit atomic_fetch_xor atomic_fetch_xor_explicit atomic_init atomic_is_lock_free atomic_load atomic_load_explicit atomic_store atomic_store_explicit async adopt_lock_t adjacent_find allocator allocator_arg_t allocator_traits auto_ptr auto_ptr_ref accumulate adjacent_difference alignment_of add_const add_cv add_lvalue_reference add_pointer add_rvalue_reference add_volatile aligned_storage aligned_union atol atoll allocate_shared atoi atof asctime acos asin atan abs acosh asinh atanh atan2 all_of any_of advance assert atomic_signal_fence atomic_thread_fence addressof atexit at_quick_exit abort atomic_flag_test_and_set atomic_flag_clear atomic_flag_test_and_set_explicit atomic_flag_clear_explicit basic_filebuf basic_fstream basic_ifstream basic_ofstream basic_ios basic_iostream basic_istream basic_ostream basic_istringstream basic_ostringstream basic_stringbuf basic_stringstream basic_streambuf binary_search bitset bad_exception bind binary_negate bit_and bit_or bit_xor bad_function_call binary_function binder1st binder2nd bidirectional_iterator_tag back_insert_iterator bad_weak_ptr bad_alloc bad_array_new_length bernoulli_distribution binomial_distribution basic_regex bad_cast bad_typeid bind1st bind2nd bsearch begin back_inserter boolalpha clock_t cerr cin clog cout condition_variable condition_variable_any cv_status copy_backward common_type  common_type  codecvt_utf16 codecvt_utf8 codecvt_utf8_utf16 codecvt_mode complex cref const_mem_fun1_ref_t const_mem_fun1_t const_mem_fun_ref_t const_mem_fun_t codecvt_base codecvt_byname collate collate_byname ctype_base ctype_byname cauchy_distribution chi_squared_distribution cmatch csub_match char_traits conditional c16rtomb c32rtomb clearerr current_exception conj const_pointer_cast ceil cbrt copysign count copy_if count_if copy_n call_once calloc clock cos cosh ctime double_t div_t deque defer_lock_t duration_values divides default_delete discrete_distribution default_random_engine discard_block_engine domain_error decay declval declare_no_pointers duration_cast dynamic_pointer_cast distance div dec defaultfloat difftime declare_reachable errno equal_range equal_to enable_shared_from_this exponential_distribution extreme_value_distribution error_category error_code error_condition extent enable_if exp erfc erf exp2 expm1 endl ends exit fenv_t fexcept_t fpclassify float_t fpos_t forward_list future future_error future_errc future_status function forward_iterator_tag front_insert_iterator float_denorm_style float_round_style fisher_f_distribution false_type fgets fopen freopen fputs fwrite fclose feof ferror fflush fgetc ftell fprintf fscanf fsetpos fgetpos fseek fputc fread future_category fesetenv feupdateenv fesetexceptflag fputws front_inserter fmod fabs floor fdim fmax fmin fma frexp fegetenv feholdexcept fegetexceptflag fgetwc fwprintf fwscanf fwide find_first_of find_end for_each find_if find_if_not feclearexcept feraiseexcept fetestexcept fesetround fixed fill_n forward_as_tuple fegetround free fputwc fgetws greater_equal gamma_distribution geometric_distribution gslice gslice_array get_temporary_buffer getchar get_terminate get_unexpected get_pointer_safety get_new_handler generic_category get_deleter gmtime generate get_money generate_n get_time generate_canonical getwchar getc getenv gets high_resolution_clock hours hash has_virtual_destructor has_facet hypot hex hexfloat isfinite isgreater isgreaterequal isinf isless islessequal islessgreater isnan isnormal isunordered ios_base io_errc includes inplace_merge is_heap is_heap_until is_permutation is_sorted is_sorted_until is_bind_expression is_placeholder initializer_list iterator iterator_traits input_iterator_tag istreambuf_iterator istream_iterator inner_product independent_bits_engine invalid_argument is_error_code_enum is_error_condition_enum ignore integral_constant is_abstract is_arithmetic is_array is_assignable is_base_of is_class is_compound is_const is_constructible is_convertible is_copy_assignable is_copy_constructible is_default_constructible is_destructible is_empty is_enum is_floating_point is_function is_fundamental is_integral is_literal_type is_lvalue_reference is_member_function_pointer is_member_object_pointer is_member_pointer is_move_assignable is_move_constructible is_nothrow_assignable is_nothrow_constructible is_nothrow_copy_assignable is_nothrow_copy_constructible is_nothrow_default_constructible is_nothrow_destructible is_nothrow_move_assignable is_nothrow_move_constructible is_null_pointer is_object is_pod is_pointer is_polymorphic is_reference is_rvalue_reference is_same is_scalar is_signed is_standard_layout is_trivial is_trivially_assignable is_trivially_constructible is_trivially_copyable is_trivially_copy_assignable is_trivially_copy_constructible is_trivially_default_constructible is_trivially_destructible is_trivially_move_assignable is_trivially_move_constructible is_union is_unsigned is_void is_volatile indirect_array isalnum isalpha isblank iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit itoa iostream_category imag ilogb iota iter_swap is_partitioned internal iswalnum iswalpha iswblank iswcntrl iswdigit iswgraph iswlower iswprint iswpunct iswspace iswupper iswxdigit iswctype jmp_buf knuth_b kill_dependency ldiv_t lldiv_t launch lock_guard lexicographical_compare lower_bound less_equal logical_and logical_not logical_or lognormal_distribution linear_congruential_engine length_error logic_error localtime log10 lgamma log1p log2 llrint llround ldexp left longjmp labs ldiv llabs lldiv localeconv log math_errhandling max_align_t mbstate_t map multimap multiset memory_order mutex make_heap max_element minmax_element min_element mismatch move_backward microseconds milliseconds minutes minus modulus multiplies messages messages_base messages_byname moneypunct moneypunct_byname money_base money_get money_put mersenne_twister_engine minstd_rand minstd_rand0 mt19937 mt19937_64 match_results make_signed make_unsigned mask_array mbrtoc16 mbrtoc32 memchr memcmp memcpy memmove memset make_shared mblen mbrlen make_move_iterator mbsinit minmax modf make_exception_ptr make_error_code make_error_condition mem_fn malloc mktime move_if_noexcept make_pair make_tuple mbstowcs mbsrtowcs mbtowc mbrtowc next_permutation nanoseconds nested_exception not_equal_to numeric_limits numpunct numpunct_byname num_get num_put nothrow_t negative_binomial_distribution notify_all_at_thread_exit nanf nanl not1 not2 nearbyint nextafter nexttoward none_of noboolalpha noshowbase noshowpoint noshowpos noskipws nounitbuf nouppercase nullptr_t nth_element once_flag output_iterator_tag ostreambuf_iterator ostream_iterator owner_less out_of_range overflow_error oct operator new operator new[] offsetof operator delete operator delete[] ptrdiff_t priority_queue packaged_task promise partial_sort partial_sort_copy partition_copy pop_heap prev_permutation push_heap plus placeholders pointer_to_binary_function pointer_to_unary_function ptr_fun pointer_traits pointer_safety partial_sum piecewise_constant_distribution piecewise_linear_distribution poisson_distribution pair piecewise_construct_t perror putchar proj put_money put_time polar pow partition_point putwchar printf putc puts qsort recursive_mutex recursive_timed_mutex replace_copy replace_copy_if reference_wrapper random_access_iterator_tag reverse_iterator raw_storage_iterator random_device ranlux24 ranlux24_base ranlux48 ranlux48_base ratio_add ratio_divide ratio_equal ratio_greater ratio_greater_equal ratio_less ratio_less_equal ratio_multiply ratio_not_equal ratio_subtract regex_constants regex_error regex_iterator regex_token_iterator regex_traits regex_replace range_error runtime_error rank remove_all_extents remove_const remove_cv remove_extent remove_pointer remove_reference remove_volatile rel_ops remove rename rewind result_of reverse_copy reverse regex_match regex_search rethrow_if_nested remainder remquo rethrow_exception replace replace_if remove_if rotate rotate_copy remove_copy remove_copy_if right resetiosflags random_shuffle return_temporary_buffer rand realloc raise return struct lconv signbit sig_atomic_t size_t stderr stdin stdout struct tm stack streamoff streampos streamsize shared_future search_n set_difference set_intersection set_symmetric_difference set_union sort_heap stable_partition stable_sort steady_clock system_clock shared_ptr student_t_distribution shuffle_order_engine subtract_with_carry_engine seed_seq sub_match ssub_match system_error strcat strcpy strncat strncpy strxfrm snprintf strtok sprintf sscanf strlen strchr strrchr strcmp strcoll strcspn strspn strpbrk strstr strncmp setbuf setvbuf strerror system_category signal strftime setfill system strtod strtof strtold strtol strtoll strtoul strtoull static_pointer_cast stoi swscanf sqrt scalbn scalbln swap_ranges setbase setlocale setprecision setw scientific setjmp set_new_handler set_terminate set_unexpected srand swprintf scanf sin sinh time_t try_to_lock_t this_thread transform treat_as_floating_point time_base time_get time_get_byname time_put time_put_byname to_string to_wstring tuple tuple_element tuple_size type_index type_info true_type tmpnam tolower toupper tmpfile towlower terminate_handler time_point_cast tgamma trunc try_lock throw_with_nested tuple_cat tie towupper towctrans tan tanh time unordered_map unordered_multimap unordered_multiset unordered_set unique_lock unique_copy upper_bound unary_negate unique_ptr uses_allocator uniform_int_distribution uniform_real_distribution underflow_error u16string u32string underlying_type uninitialized_copy uninitialized_copy_n ungetc uncaught_exception unexpected_handler undeclare_no_pointers use_facet uninitialized_fill uninitialized_fill_n undeclare_reachable ungetwc va_list vector valarray vprintf vscanf vsscanf vwscanf vfprintf vfscanf vsprintf vsnprintf vwprintf vswscanf vfwprintf vfwscanf va_end va_start va_arg va_copy vswprintf wchar_t wint_t wctrans_t wctype_t wfilebuf wfstream wifstream wofstream wios wstreampos wcerr wcin wclog wcout wiostream wistream wostream wistringstream wostringstream wstringbuf wstringstream wstreambuf wbuffer_convert wstring_convert weibull_distribution wcmatch wcsub_match wregex wsmatch wssub_match wcstombs wcsrtombs wctomb wcrtomb wmemchr wmemcmp wcstod wcstof wcstold wcstol wcstoll wcstoul wcstoull wcslen wcscmp wcscoll wcscspn wcsspn wcspbrk wcsstr wcsncmp wcschr wcsrchr wcscat wcscpy wcsncat wcsncpy wcsxfrm wmemcpy wmemmove wcsftime wmemset wcstok wctob std:: 

directives.objective.c=\
@class @defs @protocol @required @optional @end \
@interface @public @package @protected @private @property \
@implementation @synthesize @dynamic \
@throw @try @catch @finally \
@synchronized @autoreleasepool \
@selector @encode \
@compatibility_alias

# Since Objective C and C++ share the .h extension, allow Objective C directives as keywords
# For stricter display of pure C++, specify keywords.$(file.patterns.cpp)=$(keywordclass.cpp)
keywords.$(file.patterns.cpp)=$(keywordclass.cpp) $(keywordclass.cpp3) $(directives.objective.c)

#keywords2 is for highlighting user defined keywords- or function calls or similar
#keywords2.$(file.patterns.cpp)=file

# -keywords3 is for doc comment keywords-, highlighted in style 17
#CPP doxygen
file.patterns.doxygen.langs=$(file.patterns.cpp);$(file.patterns.java)
keywordclass.doxygen=a addindex addtogroup anchor arg attention \
author b brief bug c class code date def defgroup deprecated dontinclude \
e em endcode endhtmlonly endif endlatexonly endlink endverbatim enum example exception \
f$ f[ f] file fn hideinitializer htmlinclude htmlonly \
if image include ingroup internal invariant interface latexonly li line link \
mainpage name namespace nosubgrouping note overload \
p page par param param[in] param[out] \
post pre ref relates remarks return retval \
sa section see showinitializer since skip skipline struct subsection \
test throw throws todo typedef union until \
var verbatim verbinclude version warning weakgroup $ @ \ & < > # { }
keywords3.$(file.patterns.doxygen.langs)=$(keywordclass.doxygen)

# -keywords5 is for preprocessor definitions- and will cause inactive code
# to be greyed out. This setting is a space separated list of definitions
# where a definition may be of the form NAME=VALUE or simply NAME.
# keywords5.$(file.patterns.cpp)=_MSC_VER SCI_NAMESPACE GTK_MAJOR_VERSION=2

word.characters.$(file.patterns.cpp)=,$(chars.alpha)$(chars.numeric)_#.

# The position where ctrl-q inserts the comment char (Edit-> BlockComment - ctrl-q)
comment.block.at.line.start.cpp=1
comment.block.cpp=//~
comment.stream.start.cpp=/*
comment.stream.end.cpp=*/
comment.box.start.cpp=/*
comment.box.middle.cpp= *
comment.box.end.cpp= */

autocomplete.cpp.start.characters=$(chars.alpha)$(chars.numeric)$
autocomplete.cpp.fillups=	
# .ignorecase for javascript
autocomplete.cpp.ignorecase=1
autocomplete.cpp.choose.single=0

#------ \t\n makes a calltip multiline
calltip.cpp.use.escapes=1
# : for jQuery Selectors
calltip.cpp.word.characters=$(chars.alpha)$(chars.numeric):_
calltip.cpp.ignorecase=1
calltip.cpp.end.definition=)
calltip.cpp.parameters.start=(
calltip.cpp.parameters.separators=,
calltip.cpp.parameters.end=)

api.$(file.patterns.cpp)=$(SciteDefaultHome)/api/c_withdoc_03_2016.api;$(SciteDefaultHome)/user/api/c_withdoc_03_2016.api

# Folding
#fold.cpp.syntax.based=0
#fold.comment=0
#fold.cpp.comment.multiline=0
#fold.cpp.comment.explicit=0
#defaults for fold.cpp.explicit.start=//{ and fold.cpp.explicit.end=//}
#  can be replaced by defining custom strings, e.g. //[ and //]
#fold.cpp.explicit.start=//[
#fold.cpp.explicit.end=//]
#if fold strings are set to something like /*{{{ and /*}}} (Origami/WinF style fold strings), enable
#  fold.cpp.explicit.anywhere, allowing explicit fold points being anywhere, not just in line comments
#fold.cpp.explicit.anywhere=1
#fold.preprocessor=1
#fold.compact=1
#fold.at.else=1

file.patterns.c.except.cpp=$(file.patterns.idl);$(file.patterns.flash);$(file.patterns.java);$(file.patterns.ch)
statement.indent.$(file.patterns.c.except.cpp)=5 case default do else for if while
statement.indent.$(file.patterns.cpp)=5 case default do else for if private protected public while
statement.end.$(file.patterns.c.like)=10 ;
statement.lookback.$(file.patterns.c.like)=20
block.start.$(file.patterns.c.like)=10 {
block.end.$(file.patterns.c.like)=10 }

#styling.within.preprocessor=1
preprocessor.symbol.$(file.patterns.cpp)=#
preprocessor.start.$(file.patterns.cpp)=if ifdef ifndef
preprocessor.middle.$(file.patterns.cpp)=else elif
preprocessor.end.$(file.patterns.cpp)=endif

keywordclass.ch=\
auto array bool break case char class complex ComplexInf ComplexNaN \
const continue default delete \
do double else enum export extern float for foreach goto if Inf inline int \
long namespace NaN new NULL private public register restrict return short \
signed sizeof static string_t struct switch this typedef union unsigned \
using void volatile wchar_t while __declspec
keywords.$(file.patterns.ch)=$(keywordclass.ch)
word.chars.ch=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.ch)=$(word.chars.cxx)
comment.block.ch=//~
#comment.block.at.line.start.ch=1
comment.stream.start.ch=/*
comment.stream.end.ch=*/
comment.box.start.ch=/*
comment.box.middle.ch= *
comment.box.end.ch= */
preprocessor.symbol.$(file.patterns.ch)=#
preprocessor.start.$(file.patterns.ch)=if ifdef ifndef
preprocessor.middle.$(file.patterns.ch)=else elif
preprocessor.end.$(file.patterns.ch)=endif


keywordclass.go=\
bool byte break case chan complex64 complex128 const continue defer default  \
else  for func go goto fallthrough false float32 float64 if import int interface int8 int16 int32 int64 \
len map nil package range return select string struct switch true type \
uint uintptr uint8 uint16 uint32 uint64  var
keywords.$(file.patterns.go)=$(keywordclass.go)

keywordclass.rc=\
ACCELERATORS ALT AUTO3STATE AUTOCHECKBOX AUTORADIOBUTTON \
BEGIN BITMAP BLOCK BUTTON CAPTION CHARACTERISTICS CHECKBOX CLASS \
COMBOBOX CONTROL CTEXT CURSOR DEFPUSHBUTTON DIALOG DIALOGEX DISCARDABLE \
EDITTEXT END EXSTYLE FONT GROUPBOX ICON LANGUAGE LISTBOX LTEXT \
MENU MENUEX MENUITEM MESSAGETABLE POPUP \
PUSHBUTTON RADIOBUTTON RCDATA RTEXT SCROLLBAR SEPARATOR SHIFT STATE3 \
STRINGTABLE STYLE TEXTINCLUDE VALUE VERSION VERSIONINFO VIRTKEY
keywords.$(file.patterns.rc)=$(keywordclass.rc)

keywordclass.idl=\
aggregatable allocate appobject arrays async async_uuid \
auto_handle \
bindable boolean broadcast byte byte_count \
call_as callback char coclass code comm_status \
const context_handle context_handle_noserialize \
context_handle_serialize control cpp_quote custom \
decode default defaultbind defaultcollelem \
defaultvalue defaultvtable dispinterface displaybind dllname \
double dual \
enable_allocate encode endpoint entry enum error_status_t \
explicit_handle \
fault_status first_is float \
handle_t heap helpcontext helpfile helpstring \
helpstringcontext helpstringdll hidden hyper \
id idempotent ignore iid_as iid_is immediatebind implicit_handle \
import importlib in include in_line int __int64 __int3264 interface \
last_is lcid length_is library licensed local long \
max_is maybe message methods midl_pragma \
midl_user_allocate midl_user_free min_is module ms_union \
ncacn_at_dsp ncacn_dnet_nsp ncacn_http ncacn_ip_tcp \
ncacn_nb_ipx ncacn_nb_nb ncacn_nb_tcp ncacn_np \
ncacn_spx ncacn_vns_spp ncadg_ip_udp ncadg_ipx ncadg_mq \
ncalrpc nocode nonbrowsable noncreatable nonextensible notify \
object odl oleautomation optimize optional out out_of_line \
pipe pointer_default pragma properties propget propput propputref \
ptr public \
range readonly ref represent_as requestedit restricted retval \
shape short signed size_is small source strict_context_handle \
string struct switch switch_is switch_type \
transmit_as typedef \
uidefault union unique unsigned user_marshal usesgetlasterror uuid \
v1_enum vararg version void wchar_t wire_marshal

keywordclass.msidl=handle
keywordclass.xpidl=attribute native noscript scriptable shared wstring inout
keywords.$(file.patterns.idl)=$(keywordclass.idl) $(keywordclass.xpidl)

# moved java to extensions.

# this looks like Actionscript 2 - current is 3.
keywordclass.flash=add and break case catch class continue default delete do \
dynamic else eq extends false finally for function ge get gt if implements import in \
instanceof interface intrinsic le lt ne new not null or private public return \
set static super switch this throw true try typeof undefined var void while with

keywordclass2.flash=Array Arguments Accessibility Boolean Button Camera Color \
ContextMenu ContextMenuItem Date Error Function Key LoadVars LocalConnection Math \
Microphone Mouse MovieClip MovieClipLoader NetConnection NetStream Number Object \
PrintJob Selection SharedObject Sound Stage String StyleSheet System TextField \
TextFormat TextSnapshot Video Void XML XMLNode XMLSocket \
_accProps _focusrect _global _highquality _parent _quality _root _soundbuftime \
arguments asfunction call capabilities chr clearInterval duplicateMovieClip \
escape eval fscommand getProperty getTimer getURL getVersion gotoAndPlay gotoAndStop \
ifFrameLoaded Infinity -Infinity int isFinite isNaN length loadMovie loadMovieNum \
loadVariables loadVariablesNum maxscroll mbchr mblength mbord mbsubstring MMExecute \
NaN newline nextFrame nextScene on onClipEvent onUpdate ord parseFloat parseInt play \
prevFrame prevScene print printAsBitmap printAsBitmapNum printNum random removeMovieClip \
scroll set setInterval setProperty startDrag stop stopAllSounds stopDrag substring \
targetPath tellTarget toggleHighQuality trace unescape unloadMovie unLoadMovieNum updateAfterEvent

keywords.$(file.patterns.flash)=$(keywordclass.flash)
keywords2.$(file.patterns.flash)=$(keywordclass2.flash)

keywordclass.vala=if else switch case default break continue return yield for foreach in \
do while try catch finally throw

keywordclass2.vala=namespace interface class struct enum delegate signal errordomain \
construct get set value base const static var dynamic weak unowned virtual abstract \
override public protected private extern throws requires ensures yields out ref lock \
using true false null delete generic new this typeof sizeof as owned int string char bool

keywords.$(file.patterns.vala)=$(keywordclass.vala)
keywords2.$(file.patterns.vala)=$(keywordclass2.vala)

keywordclass.pike=constant enum if do for while else foreach case switch break continue \
return typeof catch class lambda import inherit static void int string float mixed object \
function program array mapping multiset
keywords.$(file.patterns.pike)=$(keywordclass.pike)

keywordclass.swift.declarations=class deinit enum extension func import init \
internal let operator private protocol public static struct subscript typealias var
keywordclass.swift.statements=break case continue default do else fallthrough \
for if in return switch where while

keywordclass.swift.expressions=as dynamicType false is nil self Self super \
true __COLUMN__ __FILE__ __FUNCTION__ __LINE__
# The contextual keywords are only keywords in particular contexts
keywordclass.swift.contextual=associativity convenience dynamic didSet final get \
infix inout lazy left mutating none nonmutating optional override postfix \
precedence prefix Protocol required right set Type unowned weak willSet

keywords.$(file.patterns.swift)=$(keywordclass.swift.declarations) \
$(keywordclass.swift.statements) $(keywordclass.swift.expressions) \
$(keywordclass.swift.contextual)

# Markers
# keywords6.$(file.patterns.c.like)=FIXME TODO XXX HACK UnresolvedMergeConflict UNDONE

#styling.within.preprocessor=1
lexer.cpp.allow.dollars=1
#lexer.cpp.track.preprocessor=1
#lexer.cpp.update.preprocessor=1

# For C# leave lexer.cpp.verbatim.strings.allow.escapes as 0 but change to 1 for Objective C
#lexer.cpp.verbatim.strings.allow.escapes=1
#lexer.cpp.triplequoted.strings=1
#lexer.cpp.hashquoted.strings=1
#lexer.cpp.backquoted.strings=1
#lexer.cpp.escape.sequence=1

#lexer.cpp.update.preprocessor=1
#lexer.cpp.escape.sequence=1

# C++ styles

# Default
style.cpp.32=$(font.default)

# White space
style.cpp.0=$(whitespace.fore),$(whitespace.back)
# Comment: /* */.
style.cpp.1=$(colour.comment.box),$(font.comment.box)
# Line Comment: //.
style.cpp.2=$(colour.comment.line),$(font.comment.line)
# Doc comment: block comments beginning with /** or /*!
style.cpp.3=$(colour.comment.doc),$(font.comment.doc)
# Number
style.cpp.4=$(colour.number)
# Keyword used ??
style.cpp.5=$(colour.keyword)
# Identifier (everything else...) used ?
style.cpp.11=$(colour.identifier)
# Style 16 for keywords 2
style.cpp.16=$(colour.keywords2)

# Double quoted string
style.cpp.6=$(colour.string)
# Single quoted string
style.cpp.7=$(colour.char)
# UUIDs (only in IDL)
style.cpp.8=$(colour.idl)
# Preprocessor
style.cpp.9=$(colour.preproc)
# Operators
style.cpp.10=$(colour.operator)
# End of line where string is not closed
style.cpp.12=$(colour.eolstringnotclosed)
# Verbatim strings for C#
style.cpp.13=$(colour.strverbatimcnet)
# Regular expressions for JavaScript
style.cpp.14=$(colour.regexjavascript)
# Doc Comment Line: line comments beginning with /// or //!.
style.cpp.15=$(colour.doccommenttripledash)
# Comment keyword
style.cpp.17=$(colour.commentkeyword)
# Comment keyword error
style.cpp.18=$(colour.commentkeyworderr)
# Global class (Keywords3 for Javascript)
style.cpp.19=$(colour.globalclass)
# Raw strings for C++0x
style.cpp.20=$(colour.cpprawstring)
# Triple-quoted strings for Vala
style.cpp.21=$(colour.valatriplequotedstring)
# Hash-quoted strings for Pike
style.cpp.22=$(colour.pikehashqoutedstring)
# Preprocessor stream comment
style.cpp.23=$(colour.preprocstreamcomment)
# Preprocessor stream doc comment
style.cpp.24=$(colour.preprocstreamdoccomment)
# User defined literals
style.cpp.25=$(colour.userdefinedliterals)
# Task Marker
style.cpp.26=$(colour.taskmarker)
# Escape sequence
style.cpp.27=$(colour.escapeseq)

# Substyles can be used for extra lists of highlighted identifiers and doc comment keywords
# Identifiers
#substyles.cpp.11=2
#substylewords.11.1.$(file.patterns.cpp)=std map string vector
#style.cpp.11.1=fore:#EE00AA
#style.cpp.75.1=$(style.cpp.75),fore:#BB6666
# Doc comment keywords
#substyles.cpp.17=1
#style.cpp.17.1=$(style.cpp.17),fore:#00AAEE
#style.cpp.81.1=$(style.cpp.81),fore:#6699AA
#substylewords.17.1.$(file.patterns.cpp)=check

# Braces are only matched in operator style
braces.cpp.style=10
ccopts=-pedantic -Os
cc=g++ $(ccopts) 
ccc=gcc $(ccopts) 

# --- Commands 

make.command=make
command.compile.*.c=cmd /c $(ccc)  *.c -o $(FileName).o  
command.build.*.c=cmd /c $(ccc) -c *.c -o $(FileName).o && g++ -o "$(FileName).exe" *.o -s $(libs) 
command.build.*.h=cmd /c $(ccc) -c *.c -o $(FileName).o && g++ -o "$(FileName).exe" *.o -s $(libs)
command.clean.*.c=del /Q $(FileName).o $(FileName).exe >NUL 
command.clean.*.h=del /Q $(FileName).o $(FileName).exe >NUL 
command.go.*.c=cmd /c $(ccc) -c *.c -o $(FileName).o && g++ -o "$(FileName).exe" *.o -s $(libs) && $(FileName).exe
# To make the Go command both compile (if needed) and execute, use this setting:
#command.go.needs.*.c=gcc $(ccopts) -std=c99 $(FileNameExt) -o $(FileName)

command.compile.$(file.patterns.cplusplus)=$(cc)
command.build.$(file.patterns.cplusplus)=$(make.command)
command.clean.$(file.patterns.cplusplus)=$(make.command) clean
command.go.$(file.patterns.cplusplus)=./$(FileName)
command.go.needs.$(file.patterns.cplusplus)=g++ $(ccopts) $(FileNameExt) -o $(FileName)


if PLAT_WIN
	command.compile.*.rc=windres $(FileNameExt) $(FileName).o
	command.build.*.rc=$(make.command)
	command.help.$(file.patterns.cpp)=$(CurrentWord)!G:\Program Files\Microsoft Visual Studio\MSDN98\98VSa\1033\MSDNVS6A.COL
	command.help.subsystem.$(file.patterns.cpp)=4
# When maintaining old Win16 programs...
#	command.help.$(file.patterns.cpp)=$(CurrentWord)!I:\msvc\help\win31wh.hlp
#	command.help.subsystem.$(file.patterns.cpp)=5

if PLAT_GTK
	command.help.$(file.patterns.cpp)=man $(CurrentWord) | col -b

if PLAT_WIN
	command.build.*.cs=csc /t:winexe $(FileNameExt) /r:system.dll,system.drawing.dll
	command.go.*.cs=$(FileName)
	command.go.subsystem.*.cs=0
if PLAT_GTK
	command.build.*.cs=mcs /t:winexe $(FileNameExt) /r:System,System.Drawing
	command.go.*.cs=mono $(FileName).exe
	command.go.subsystem.*.cs=1


command.compile.*.ch=ch -n $(FileNameExt)
command.build.*.ch=ch -n  $(FileNameExt)
command.go.*.ch=ch -u $(FileNameExt)

command.compile.*.as=mtasc -strict $(FileNameExt)
command.build.*.as=mtasc -strict *.as

command.build.$(file.patterns.vala)=valac $(FileNameExt)
command.go.*.vala=./$(FileName)

# can also be 6g for 64-bit systems!
command.compile.*.go=8g $(FileNameExt)
command.build.*.go=$(make.command)
command.go.*.go=./$(FileName)

# -- Define regexp for sidbar functions
routines.regex.c=(static\s+)?(\w+\s+)?\w+[\s\*]+\w+\s*\(((\s*\w+\s+\w+\s*)(,)?)*\)
routines.regex.h=$(routines.regex.c)
routines.regex.cpp=(static\s+)?(\w+\s+)?\w+[\s\*]+(\w+::)?\w+\s*\([\w\s\*\[\],]*\)
routines.regex.hpp=$(routines.regex.cpp)
